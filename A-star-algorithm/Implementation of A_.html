<!DOCTYPE html>
<!-- saved from url=(0067)https://www.redblobgames.com/pathfinding/a-star/implementation.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Implementation of A*</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" as="image" href="https://www.redblobgames.com/img/transparent-blob.png"><link rel="canonical" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html"><link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="https://simblob.blogspot.com/feeds/posts/default"><meta name="twitter:creator" content="@redblobgames"><meta name="theme-color" content="hsl(0,50%,45%)"><meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk="><style>
              body{--hue: 0;--serif: Cambria,Georgia,serif;--sans-serif: system-ui,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;--monospace: "Roboto Mono","Consolas",monospace,"Segoe UI Symbol","Symbol";--font-size: 16px;--font-size: calc(10px + 1vw);--line-height: 24px;--line-height: calc(1.5 * var(--font-size));--body-width: 660px;--body-width: calc(100vw - 36px);font-family:sans-serif;font-family:var(--sans-serif);font-size:16px;font-size:var(--font-size);line-height:1.5em;min-height:95%}@media (min-width: 550px){body{--body-width: calc(330px + 33vw);--font-size: calc(var(--body-width) / 33)}}@media (min-width: 1000px){body{--body-width: 660px}}main{font-family:var(--serif)}h1,h2,h3,h4,h5,h6,figcaption,.sans-serif{font-family:var(--sans-serif)}tt,code,kbd,samp,pre{font-family:monospace;font-family:var(--monospace);font-size:0.8em;font-size-adjust:none}#table-of-contents{background-color:#fff;margin-left:2em;padding-left:2em;width:20em;float:right}#table-of-contents:after{clear:both}nav,#table-of-contents{font-family:var(--sans-serif);font-size:calc(var(--font-size) / 1.25)}@media screen{header,section>h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility}}h1{font-size:2.0em;margin:0;line-height:36px;line-height:calc(1.5 * var(--line-height))}h1 .subheading{font-size:0.5em;letter-spacing:normal;line-height:24px;line-height:var(--line-height)}sup,sub{position:relative;vertical-align:baseline;font-size:0.75em;line-height:0;padding-left:2px}sup{top:-0.5em}sub{bottom:-0.25em}*{box-sizing:border-box}html,body{margin:0;padding:0}html{background-color:#e4e4e0;color:#000}body{background-color:#fff;color:#333}header{display:block;text-align:center}header>h1{padding-top:24px;padding-top:var(--line-height)}@media screen{.colored-background,header,footer,.divider,section>h2{color:#fff;background-color:#ac3939;background-color:hsl(var(--hue), 50%, 45%);background-image:url("/img/transparent-blob.png"),url("/img/transparent-blob.png");background-position:0 0, 16px 16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.colored-background a,header a,footer a,.divider a,section>h2 a{color:#f0dbdb;color:hsl(var(--hue), 40%, 90%)}}footer a,.divider a{text-decoration:underline}main{margin-left:0;margin-right:0;padding-left:0;padding-right:0}section{margin-top:24px;margin-bottom:24px;margin-top:var(--line-height);margin-bottom:var(--line-height)}section>*,.comments{width:660px;width:var(--body-width);max-width:100%}.w-auto,section>.w-auto{width:auto}@media screen{.comments,.below-divider{background-color:#e4e4e0}}.comments{padding-bottom:20px;text-shadow:1px 1px 3px #fff;font-size:0.8em}section>h2{--h2-margin: 3em;--h2-padding: 0.5em;margin:24px auto;margin:var(--line-height) auto;padding:calc(var(--line-height) / 2 - 1px) 0;font-size:1.25em;width:740px;width:calc(2 * var(--h2-margin) + var(--body-width));max-width:100%}section>h2>span{display:inline-block;margin-left:var(--h2-margin)}section>h2 a.anchor{float:right;width:var(--h2-margin);padding-right:var(--h2-padding);text-align:center;color:#ac3939;color:hsl(var(--hue), 50%, 45%)}section>h2:hover a.anchor{color:#d6c2c2;color:hsl(var(--hue), 20%, 80%)}h3{--h2-margin: 3em;margin:24px auto;margin:var(--line-height) auto;font-size:1.125em}h3 a.anchor{float:right;width:var(--h2-margin);padding-right:0.5em;text-align:center;color:#d6c2c2;color:hsl(var(--hue), 20%, 80%)}@media (min-width: 550px){h3 a.anchor{margin-right:calc(0em - var(--h2-margin))}}h3:hover a.anchor{color:#933;color:hsl(var(--hue), 50%, 40%)}header nav{display:block}header nav ul{text-align:center;display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:center;justify-content:center;line-height:1.0;margin:0}header nav ul li{display:inline-block;width:10%;padding:2px 5px;text-align:center;-ms-flex:0 0 4em;flex:0 0 4em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;white-space:nowrap}header nav ul li a{display:block;width:100%;font-weight:bold;text-decoration:none}header nav ul li:hover{background-color:rgba(0,0,0,0.5);font-weight:bold}header,.divider,section>h2{border-bottom:1px solid #000}.divider,section>h2{border-top:1px solid #000}.divider{min-height:48px;min-height:calc(2 * var(--line-height));text-align:center}.below-divider{padding-top:24px;padding-top:var(--line-height)}.below-divider>p:first-child{font-size:1.25em;text-align:center;margin-top:0}footer{--footer-padding-y: calc(var(--line-height) / 2);--footer-padding-x: var(--font-size);padding:12px 16px;padding:var(--footer-padding-y) var(--footer-padding-x);border-top:1px solid #000}footer>div>address{display:block}footer>div>*{text-align:center}@media (min-width: 50em){footer>div{margin:0 auto;display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:center;justify-content:center;max-width:calc(2 * var(--body-width));width:calc(100vw - 2 * var(--footer-padding-x))}footer>div>address{-ms-flex:0 1 20em;flex:0 1 20em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;text-align:left}footer>div>div{-ms-flex:1 1 20em;flex:1 1 20em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;text-align:right}footer>div>div>p,footer>div>div>div{margin-top:0}}h2:target{animation:target-attention 0.4s 1;font-size:2.0em}@keyframes target-attention{0%{transform:scale(1.1)}100%{transform:scale(1.1)}}div:target{border:1px dashed #888}kbd kbd{padding:1px 7px;margin:0px 1px 3px 1px;font-size:0.75em;white-space:nowrap;background-color:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:3px;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f3f3f2}code,samp{color:#442}kbd{margin:0 7px;color:#252}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic}section figcaption{font-size:0.75em;line-height:1.1;text-align:center}a{color:#ac3939;color:hsl(var(--hue), 50%, 45%);text-decoration:none}a:hover{text-decoration:underline}.draft{font-family:var(--serif);font-size:calc(4 * var(--font-size));color:#eee;opacity:0.5;text-align:center;transform:rotate(-5deg);line-height:1.0;position:absolute;top:0;height:0;left:25%;width:50%;letter-spacing:-10px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none}h1,h2,h3,h4,h5,h6{-webkit-font-feature-settings:"liga", "clig", "calt", "kern", "palt";font-feature-settings:"liga", "clig", "calt", "kern", "palt";-webkit-font-variant-ligatures:common-ligatures contextual;font-variant-ligatures:common-ligatures contextual}h1:first-char,h2:first-char,h3:first-char{font-variant-numeric:normal}section p,section li{-webkit-font-feature-settings:"liga", "clig", "calt", "onum", "kern", "palt";font-feature-settings:"liga", "clig", "calt", "onum", "kern", "palt";-webkit-font-variant-ligatures:normal;font-variant-ligatures:normal;font-variant-numeric:oldstyle-nums;hanging-punctuation:first last;text-align:justify;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}nav,figure,td,th,abbr,acronym,code,kbd,samp,tt,var,pre{-webkit-font-feature-settings:"liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;font-feature-settings:"liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;-webkit-font-variant-ligatures:none;font-variant-ligatures:none;font-variant-numeric:lining-nums tabular-nums slashed-zero;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}.w-auto{width:auto}.select-none{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.text-center{text-align:center}.text-sm{font-size:0.875em}.font-sans{font-family:var(--sans-serif)}.font-serif{font-family:var(--serif)}.font-mono{font-family:var(--monospace)}p,figure,ul,ol{margin:24px 0;margin-top:var(--line-height);margin-bottom:var(--line-height)}header>*,section>*,footer>*,main>address,.comments{margin-left:auto;margin-right:auto}figure{text-align:center}li>ul,li>ol{margin-top:0;margin-bottom:0}figure img,figure svg,figure canvas{max-width:100%}dt{font-weight:bold}pre{width:660px;width:var(--body-width);max-width:100%;line-height:1.4;overflow:auto;border-top:1px solid #ccc;border-bottom:1px solid #ccc;border-left-width:0;border-right-width:0}pre::-webkit-scrollbar{height:1em}pre::-webkit-scrollbar-thumb:horizontal{border-radius:0.5em;background:rgba(0,0,0,0.4)}pre.simple,.comments pre{overflow:auto;width:calc(var(--body-width) * 1.2);border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}section>pre:only-child{padding-bottom:16px;border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic}table.standard{border:1px solid rgba(0,0,0,0.5);border-collapse:collapse}table.standard th{background-color:#f8f8f8;background:linear-gradient(to top, #f8f8f8, #f8f8f8, #f0f0f0)}table.standard td{background-color:#fff}table.standard th,table.standard td{border:1px solid rgba(0,0,0,0.5)}aside,p.note,div.note>p{width:calc(--body-width - 2em);padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}svg{overflow:hidden}tt,code{padding:0 2px}main>address,section>address,section>time{display:block;width:var(--body-width);max-width:100%;font-family:var(--sans-serif);text-align:right}@media (max-width: 600px){header nav{display:none}}form{margin:0}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::-webkit-input-placeholder{color:#aaa}input::-moz-placeholder{color:#aaa}input[type="search"][name="q"]{box-shadow:inset 0 2px 5px 0 rgba(0,0,0,0.5);border-radius:10px;padding:5px 10px;border-width:0}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}.src .comment-delimiter,.src .nxml-comment-delimiter{color:#4488ff}.src .comment,.src .nxml-comment-content{color:#006699}.src .keyword{color:#406abf;font-weight:bold}.src .builtin{color:#508b20}.src .warning{color:#cc0000}.src .function-name{color:#268bd2;font-weight:bold}.src .variable-name{color:#00008b}.src .type{color:#6c71c4}.src .constant-face{color:#d33682}.src .doc{color:#666666;background-color:#e2e6e8}.src .string{color:#888888}.src .preprocessor{color:#859900}.src .negation-char,.src .sh-escaped-newline{color:#ff0000}.src .todo{color:#ffffff;background:#dc322f}.src .note{color:#ffffff;background:#2aa198}.src .hack{color:#ffffff;background:#859900}.src .paren{color:#a0a090;font-weight:bold}.src .minor-control-construct{color:#268bd2}.src .major-control-construct{color:#bf4040}.src-cpp .constant{color:#999999}.src-emacs-lisp .paren{color:#c9c9c4}.src-sh .string,.src-sh .comment{color:inherit}.src-python .highlight-indentation{border-right:2px solid #eeeeee}.src-css .css-selector{color:#478547}.src-css .css-property{color:#406abf}.src-xml .nxml-element-prefix{color:#bf40bf}.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}.src-xml .nxml-attribute-local-name{color:#478547}.src-xml .nxml-element-colon{color:#a3adc2}.src-xml .nxml-tag-delimiter,.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}@media screen{*[class^="section-number"]{color:hsl(var(--hue), 20%, 50%)}h2 .section-number{display:inline-block;margin-left:0;padding-left:0.5em;text-align:center;width:var(--h2-margin);color:hsl(var(--hue), 50%, 80%)}h2 .section-number+span{margin-left:0}h3 .section-number{float:left;text-align:center;width:2em;margin-right:0.5em;color:hsl(var(--hue), 25%, 90%);background:hsl(var(--hue), 50%, 50%);border-radius:4px;text-shadow:0px 2px 5px rgba(0,0,0,0.8)}}@media screen and (min-width: 550px){h3 .section-number{background:url(/img/svg-blob-mini.svg) no-repeat center center;background-size:2em 2em;height:2em;margin-left:-2.5em;margin-top:-0.3em;padding-top:0.3em}}.print-endnote{display:none}@media print{@page{margin:1in}body{--font-size: 13pt;--body-width: 100vw;--serif: "Book Antiqua", "Times New Roman", serif;--sans-serif: "Helvetica", sans-serif;--monospace: "Courier", "Courier New", monospace}h2,h3{page-break-after:avoid}figure{page-break-inside:avoid}p,li{orphans:5;widows:5}section p a,section li a{text-decoration:underline}header nav,.comments{display:none}.print-endnote{display:unset}.print-endnote li{list-style-type:none;word-break:break-all}}

            
          @media print{header::before{position:absolute;left:0;top:0;content:url(http://chart.apis.google.com/chart?chs=120x120&cht=qr&chl=https%3A%2F%2Fwww.redblobgames.com%2Fpathfinding%2Fa-star%2Fimplementation.html);}}
	  
  /* Need 70 columns for code, and with these extra margins it was too small, so I decreased font size .. */
  pre {
    font-size: 0.6em; 
  }
  pre.src { 
    white-space: pre; 
    border: 8px solid hsl(60, 20%, 95%); 
    padding: 8px 16px; 
    margin-bottom: 0; 
    box-shadow: inset 0 0 2px 1px hsla(60, 10%, 50%, 0.5); 
  }
  pre.example { 
    background: hsl(60, 20%, 95%); 
    padding-left: 16px; 
    border-top: none; 
    border-bottom: none; 
    white-space: pre; 
  }
  div.org-src-container + pre.example { 
    margin-top: 0; 
  }
</style><style type="text/css">
@font-face {
  font-weight: 400;
  font-style:  normal;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-Regular.woff2') format('woff2');
}
@font-face {
  font-weight: 400;
  font-style:  italic;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-Italic.woff2') format('woff2');
}

@font-face {
  font-weight: 500;
  font-style:  normal;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-Medium.woff2') format('woff2');
}
@font-face {
  font-weight: 500;
  font-style:  italic;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-MediumItalic.woff2') format('woff2');
}

@font-face {
  font-weight: 700;
  font-style:  normal;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-Bold.woff2') format('woff2');
}
@font-face {
  font-weight: 700;
  font-style:  italic;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-BoldItalic.woff2') format('woff2');
}

@font-face {
  font-weight: 900;
  font-style:  normal;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-Black.woff2') format('woff2');
}
@font-face {
  font-weight: 900;
  font-style:  italic;
  font-family: 'Inter-Loom';

  src: url('https://cdn.useloom.com/assets/fonts/inter/Inter-UI-BlackItalic.woff2') format('woff2');
}</style></head><body class="gameprog" cz-shortcut-listen="true"><header><h1>Implementation of A*</h1><div class="subheading">
                from <a href="https://www.redblobgames.com/">Red Blob Games</a></div><nav><form action="https://www.google.com/search"><ul> <li><a href="https://www.redblobgames.com/">Home</a></li> <li><a href="https://simblob.blogspot.com/">Blog</a></li> <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li><a href="https://twitter.com/redblobgames">Twitter</a></li> <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li> </li><li><input type="search" name="q" placeholder="Search" size="8"></li></ul><input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com"></form></nav></header><main><address>6 Jul 2014</address><div id="table-of-contents"><h2>Table of Contents</h2><div id="text-table-of-contents"><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python">1. Python Implementation</a><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-breadth-first">1.1. Breadth First Search</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-early-exit">1.2. Early Exit</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-dijkstra">1.3. Dijkstra’s Algorithm</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-astar">1.4. A* Search</a></li></ul></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cplusplus">2. C++ Implementation</a><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-breadth-first">2.1. Breadth First Search</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-early-exit">2.2. Early Exit</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-dijkstra">2.3. Dijkstra’s Algorithm</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-astar">2.4. A* Search</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#orge610868">2.5. Production code</a></li></ul></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#csharp">3. C# Implementation</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm">4. Algorithm changes</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimizations">5. Optimizations</a><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-graph">5.1. Graph</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-queue">5.2. Queue</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-search">5.3. Search</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-integer-ids">5.4. Integer locations</a></li></ul></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting">6. Troubleshooting</a><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting-wrong-path">6.1. Wrong path</a></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting-ugly-path">6.2. Ugly path</a></li></ul></li><li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#more">7. More reading</a></li></ul></div></div><section><div class="note"><p>This article is a companion guide to my <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">introduction to A*</a>. I show how to implement Breadth-First Search, Dijkstra’s Algorithm, Greedy Best-First Search, and A*. I focused on keeping things simple.</p></div><p>Graph search is a family of related algorithms. There are <i>lots</i> of variants of the algorithms, and lots of variants in implementation. Treat the code on this page as a starting point, not as a final version of the algorithm that works for all situations.</p></section><section><h2 id="python"><span class="section-number">&nbsp;1&nbsp; </span><span>Python Implementation</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python">#</a></h2><div class="outline-text-2" id="text-python"><p>I explain most of the code below. There are a few extra bits that you can find in <a href="https://www.redblobgames.com/pathfinding/a-star/implementation.py">implementation.py</a>. These use <b>Python 3</b> so if you use Python 2, you will need to change the <code>super()</code> call and the <code>print</code> function to the Python 2 equivalents.</p></div><h3 id="python-breadth-first"><span class="section-number">&nbsp;1.1&nbsp;</span><span>Breadth First Search</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-breadth-first">#</a></h3><p>Let’s implement Breadth First Search in Python. The main article shows the Python code for the search algorithm, but we also need to define the graph it works on. These are the abstractions I’ll use:</p><dl class="org-dl"><dt>Graph</dt><dd>a data structure that can tell me the <code>neighbors</code> for each location (see <a href="https://www.redblobgames.com/pathfinding/grids/graphs.html">this tutorial</a>). A <i>weighted</i> graph can also tell me the <code>cost</code> of moving along an edge.</dd><dt>Locations</dt><dd>a simple value (int, string, tuple, etc.) that <i>labels</i> locations in the graph</dd><dt>Search</dt><dd>an algorithm that takes a graph, a starting location, and optionally a goal location, and calculates some useful information (visited, parent pointer, distance) for some or all locations</dd><dt>Queue</dt><dd>a data structure used by the search algorithm to decide the order in which to process the locations</dd></dl><p>In the main article, I focused on <b>search</b>. On this page, I’ll fill in the rest of the details to make complete working programs. Let’s start with a <b>graph</b>:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">class</span> <span class="type">SimpleGraph</span>:
    <span class="minor-control-construct">def</span> <span class="function-name">__init__</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="keyword">self</span>.edges = <span class="paren">{}</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">neighbors</span><span class="paren">(</span><span class="keyword">self</span>, <span class="builtin">id</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="keyword">self</span>.edges<span class="paren">[</span><span class="builtin">id</span><span class="paren">]</span>
</pre></div><p>Yep, that’s all we need! You may be asking, where’s the Node object? The answer is: I rarely use a node object. I find it simpler to use integers, strings, or tuples as locations, and then use arrays or hash tables that use locations as an index.</p><p>Note that the edges are <i>directed</i>: we can have an edge from A to B without also having an edge from B to A. In game maps most edges are bidirectional but sometimes there are one-way doors or jumps off cliffs that are expressed as directed edges. Let’s make an example graph, where the <b>locations</b> are letters A-E.</p><div class="RESULTS"><div class="figure"><p><img src="./Implementation of A__files/implementation-example-graph.png" alt="implementation-example-graph.png"></p></div></div><p>For each location I need a list of which locations it leads to:</p><div class="org-src-container"><pre class="src src-python"><span class="variable-name">example_graph</span> = SimpleGraph<span class="paren">()</span>
<span class="variable-name">example_graph.edges</span> = <span class="paren">{</span>
    <span class="string">'A'</span>: <span class="paren">[</span><span class="string">'B'</span><span class="paren">]</span>,
    <span class="string">'B'</span>: <span class="paren">[</span><span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'D'</span><span class="paren">]</span>,
    <span class="string">'C'</span>: <span class="paren">[</span><span class="string">'A'</span><span class="paren">]</span>,
    <span class="string">'D'</span>: <span class="paren">[</span><span class="string">'E'</span>, <span class="string">'A'</span><span class="paren">]</span>,
    <span class="string">'E'</span>: <span class="paren">[</span><span class="string">'B'</span><span class="paren">]</span>
<span class="paren">}</span>
</pre></div><p>Before we can use it with a search algorithm, we need to make a <b>queue</b>:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">import</span> collections

<span class="minor-control-construct">class</span> <span class="type">Queue</span>:
    <span class="minor-control-construct">def</span> <span class="function-name">__init__</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="keyword">self</span>.elements = collections.deque<span class="paren">()</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">empty</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="builtin">len</span><span class="paren">(</span><span class="keyword">self</span>.elements<span class="paren">)</span> == <span class="constant">0</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">put</span><span class="paren">(</span><span class="keyword">self</span>, x<span class="paren">)</span>:
        <span class="keyword">self</span>.elements.append<span class="paren">(</span>x<span class="paren">)</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">get</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="keyword">self</span>.elements.popleft<span class="paren">()</span>
</pre></div><p>This queue class is just a wrapper around the built-in <code>collections.deque</code> class. Feel free to use <code>deque</code> directly in your own code.</p><p>Let’s try the example graph with this queue and the breadth-first search algorithm code from the main article:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *

<span class="minor-control-construct">def</span> <span class="function-name">breadth_first_search_1</span><span class="paren">(</span>graph, start<span class="paren">)</span>:
    <span class="comment-delimiter"># </span><span class="comment">print out what we find</span>
    <span class="variable-name">frontier</span> = Queue<span class="paren">()</span>
    frontier.put<span class="paren">(</span>start<span class="paren">)</span>
    <span class="variable-name">visited</span> = <span class="paren">{}</span>
    <span class="variable-name">visited</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">True</span>
    
    <span class="minor-control-construct">while</span> <span class="keyword">not</span> frontier.empty<span class="paren">()</span>:
        <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>
        <span class="keyword">print</span><span class="paren">(</span><span class="string">"Visiting %r"</span> % current<span class="paren">)</span>
        <span class="minor-control-construct">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors<span class="paren">(</span>current<span class="paren">)</span>:
            <span class="minor-control-construct">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:
                frontier.put<span class="paren">(</span><span class="builtin">next</span><span class="paren">)</span>
                <span class="variable-name">visited</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = <span class="constant">True</span>

breadth_first_search_1<span class="paren">(</span>example_graph, <span class="string">'A'</span><span class="paren">)</span>
</pre></div><pre class="example">Visiting 'A'
Visiting 'B'
Visiting 'C'
Visiting 'D'
Visiting 'E'
</pre><p>Grids can be expressed as graphs too. I’ll now define a new <b>graph</b> called <code>SquareGrid</code>, with <b>locations</b> tuples (int, int). Instead of storing the edges explicitly, I’ll calculate them in the <code>neighbors</code> function.</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">class</span> <span class="type">SquareGrid</span>:
    <span class="minor-control-construct">def</span> <span class="function-name">__init__</span><span class="paren">(</span><span class="keyword">self</span>, width, height<span class="paren">)</span>:
        <span class="keyword">self</span>.width = width
        <span class="keyword">self</span>.height = height
        <span class="keyword">self</span>.walls = <span class="paren">[]</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">in_bounds</span><span class="paren">(</span><span class="keyword">self</span>, <span class="builtin">id</span><span class="paren">)</span>:
        <span class="paren">(</span>x, y<span class="paren">)</span> = <span class="builtin">id</span>
        <span class="major-control-construct">return</span> <span class="constant">0</span> &lt;= x &lt; <span class="keyword">self</span>.width <span class="keyword">and</span> <span class="constant">0</span> &lt;= y &lt; <span class="keyword">self</span>.height
    
    <span class="minor-control-construct">def</span> <span class="function-name">passable</span><span class="paren">(</span><span class="keyword">self</span>, <span class="builtin">id</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="builtin">id</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.walls
    
    <span class="minor-control-construct">def</span> <span class="function-name">neighbors</span><span class="paren">(</span><span class="keyword">self</span>, <span class="builtin">id</span><span class="paren">)</span>:
        <span class="paren">(</span>x, y<span class="paren">)</span> = <span class="builtin">id</span>
        <span class="variable-name">results</span> = <span class="paren">[(</span>x+<span class="constant">1</span>, y<span class="paren">)</span>, <span class="paren">(</span>x, y-<span class="constant">1</span><span class="paren">)</span>, <span class="paren">(</span>x-<span class="constant">1</span>, y<span class="paren">)</span>, <span class="paren">(</span>x, y+<span class="constant">1</span><span class="paren">)]</span>
        <span class="minor-control-construct">if</span> <span class="paren">(</span>x + y<span class="paren">)</span> % <span class="constant">2</span> == <span class="constant">0</span>: results.reverse<span class="paren">()</span> <span class="comment-delimiter"># </span><span class="comment">aesthetics</span>
        <span class="variable-name">results</span> = <span class="builtin">filter</span><span class="paren">(</span><span class="keyword">self</span>.in_bounds, results<span class="paren">)</span>
        <span class="variable-name">results</span> = <span class="builtin">filter</span><span class="paren">(</span><span class="keyword">self</span>.passable, results<span class="paren">)</span>
        <span class="major-control-construct">return</span> results
</pre></div><p>Let’s try it out with the first grid in the main article:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *
<span class="variable-name">g</span> = SquareGrid<span class="paren">(</span><span class="constant">30</span>, <span class="constant">15</span><span class="paren">)</span>
<span class="variable-name">g.walls</span> = DIAGRAM1_WALLS <span class="comment-delimiter"># </span><span class="comment">long list, </span><span class="comment"><span class="paren">[(</span></span><span class="comment">21, 0</span><span class="comment"><span class="paren">)</span></span><span class="comment">, </span><span class="comment"><span class="paren">(</span></span><span class="comment">21, 2</span><span class="comment"><span class="paren">)</span></span><span class="comment">, ...</span><span class="comment"><span class="paren">]</span></span>
draw_grid<span class="paren">(</span>g<span class="paren">)</span>
</pre></div><pre class="example">. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . ####. . . . . . . . . . . . . . . . ####. . . . . . . 
. . . ####. . . . . . . . ####. . . . . . ####. . . . . . . 
. . . ####. . . . . . . . ####. . . . . . ##########. . . . 
. . . ####. . . . . . . . ####. . . . . . ##########. . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . . 
</pre><p>In order to reconstruct paths we need to store the location of where we came from, so I’ve renamed <code>visited</code> (True/False) to <code>came_from</code> (location):</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *

<span class="minor-control-construct">def</span> <span class="function-name">breadth_first_search_2</span><span class="paren">(</span>graph, start<span class="paren">)</span>:
    <span class="comment-delimiter"># </span><span class="comment">return "came_from"</span>
    <span class="variable-name">frontier</span> = Queue<span class="paren">()</span>
    frontier.put<span class="paren">(</span>start<span class="paren">)</span>
    came_<span class="minor-control-construct">from</span> = <span class="paren">{}</span>
    came_<span class="minor-control-construct">from</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">None</span>
    
    <span class="minor-control-construct">while</span> <span class="keyword">not</span> frontier.empty<span class="paren">()</span>:
        <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>
        <span class="minor-control-construct">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors<span class="paren">(</span>current<span class="paren">)</span>:
            <span class="minor-control-construct">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_<span class="minor-control-construct">from</span>:
                frontier.put<span class="paren">(</span><span class="builtin">next</span><span class="paren">)</span>
                came_<span class="minor-control-construct">from</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = current
    
    <span class="major-control-construct">return</span> came_<span class="minor-control-construct">from</span>

<span class="variable-name">g</span> = SquareGrid<span class="paren">(</span><span class="constant">30</span>, <span class="constant">15</span><span class="paren">)</span>
<span class="variable-name">g.walls</span> = DIAGRAM1_WALLS

<span class="variable-name">parents</span> = breadth_first_search_2<span class="paren">(</span>g, <span class="paren">(</span><span class="constant">8</span>, <span class="constant">7</span><span class="paren">))</span>
draw_grid<span class="paren">(</span>g, width=<span class="constant">2</span>, point_to=parents, start=<span class="paren">(</span><span class="constant">8</span>, <span class="constant">7</span><span class="paren">))</span>
</pre></div><pre class="example">&gt; &gt; &gt; &gt; v v v v v v v v v v v v &lt; &lt; &lt; &lt; &lt; ####v v v v v v v 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; ####v v v v v v v 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; &lt; ####&gt; v v v v v v 
&gt; &gt; ^ ####v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; ####&gt; &gt; v v v v v 
&gt; ^ ^ ####&gt; v v v v v v &lt; ####^ &lt; &lt; &lt; &lt; &lt; ####&gt; &gt; &gt; v v v v 
^ ^ ^ ####&gt; &gt; v v v v &lt; &lt; ####^ ^ &lt; &lt; &lt; &lt; ##########v v v &lt; 
^ ^ ^ ####&gt; &gt; &gt; v v &lt; &lt; &lt; ####^ ^ ^ &lt; &lt; &lt; ##########v v &lt; &lt; 
^ ^ ^ ####&gt; &gt; &gt; A &lt; &lt; &lt; &lt; ####^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####&gt; &gt; ^ ^ ^ &lt; &lt; &lt; ####^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####&gt; ^ ^ ^ ^ ^ &lt; &lt; ####^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####^ ^ ^ ^ ^ ^ ^ &lt; ####^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; v v ####^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; 
</pre><p>Some implementations use <i>internal storage</i>, creating a Node object to hold <code>came_from</code> and other values for each graph node. I’ve instead chosen to use <i>external storage</i>, creating a single hash table to store the <code>came_from</code> for all graph nodes. If you know your map locations have integer indices, another option is to use an array to store <code>came_from</code>.</p><h3 id="python-early-exit"><span class="section-number">&nbsp;1.2&nbsp;</span><span>Early Exit</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-early-exit">#</a></h3><p>Following the code from the main article, all we need to do is add an <i>if</i> statement in the main loop. This test is optional for Breadth First Search or Dijkstra’s Algorithm and effectively required for Greedy Best-First Search and A*:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *

<span class="minor-control-construct">def</span> <span class="function-name">breadth_first_search_3</span><span class="paren">(</span>graph, start, goal<span class="paren">)</span>:
    <span class="variable-name">frontier</span> = Queue<span class="paren">()</span>
    frontier.put<span class="paren">(</span>start<span class="paren">)</span>
    came_<span class="minor-control-construct">from</span> = <span class="paren">{}</span>
    came_<span class="minor-control-construct">from</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">None</span>
    
    <span class="minor-control-construct">while</span> <span class="keyword">not</span> frontier.empty<span class="paren">()</span>:
        <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>
        
        <span class="minor-control-construct">if</span> current == goal:
            <span class="major-control-construct">break</span>
        
        <span class="minor-control-construct">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors<span class="paren">(</span>current<span class="paren">)</span>:
            <span class="minor-control-construct">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_<span class="minor-control-construct">from</span>:
                frontier.put<span class="paren">(</span><span class="builtin">next</span><span class="paren">)</span>
                came_<span class="minor-control-construct">from</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = current
    
    <span class="major-control-construct">return</span> came_<span class="minor-control-construct">from</span>

<span class="variable-name">g</span> = SquareGrid<span class="paren">(</span><span class="constant">30</span>, <span class="constant">15</span><span class="paren">)</span>
<span class="variable-name">g.walls</span> = DIAGRAM1_WALLS

<span class="variable-name">parents</span> = breadth_first_search_3<span class="paren">(</span>g, <span class="paren">(</span><span class="constant">8</span>, <span class="constant">7</span><span class="paren">)</span>, <span class="paren">(</span><span class="constant">17</span>, <span class="constant">2</span><span class="paren">))</span>
draw_grid<span class="paren">(</span>g, width=<span class="constant">2</span>, point_to=parents, start=<span class="paren">(</span><span class="constant">8</span>, <span class="constant">7</span><span class="paren">)</span>, goal=<span class="paren">(</span><span class="constant">17</span>, <span class="constant">2</span><span class="paren">))</span>
</pre></div><pre class="example">. &gt; &gt; &gt; v v v v v v v v v v v v &lt; . . . . ####. . . . . . . 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v v &lt; &lt; &lt; . . . ####. . . . . . . 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v &lt; &lt; &lt; Z . . . ####. . . . . . . 
&gt; &gt; ^ ####v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; . . ####. . . . . . . 
. ^ ^ ####&gt; v v v v v v &lt; ####^ &lt; &lt; . . . ####. . . . . . . 
. . ^ ####&gt; &gt; v v v v &lt; &lt; ####^ ^ . . . . ##########. . . . 
. . . ####&gt; &gt; &gt; v v &lt; &lt; &lt; ####^ . . . . . ##########. . . . 
. . . ####&gt; &gt; &gt; A &lt; &lt; &lt; &lt; ####. . . . . . . . . . . . . . . 
. . . ####&gt; &gt; ^ ^ ^ &lt; &lt; &lt; ####. . . . . . . . . . . . . . . 
. . v ####&gt; ^ ^ ^ ^ ^ &lt; &lt; ####. . . . . . . . . . . . . . . 
. v v ####^ ^ ^ ^ ^ ^ ^ &lt; ####. . . . . . . . . . . . . . . 
&gt; v v ####^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
&gt; &gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
&gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
. &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
</pre><p>You can see that the algorithm stops when it finds the goal <code>Z</code>.</p><h3 id="python-dijkstra"><span class="section-number">&nbsp;1.3&nbsp;</span><span>Dijkstra’s Algorithm</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-dijkstra">#</a></h3><div class="outline-text-3" id="text-python-dijkstra"><p>This is what adds complexity to graph search, because we’re going to start processing locations in a better order than “first in, first out”. What do we need to change?</p><ol class="org-ol"><li>The <i>graph</i> needs to know cost of movement.</li><li>The <i>queue</i> needs to return nodes in a different order.</li><li>The <i>search</i> needs to keep track of these costs from the graph and give them to the queue.</li></ol></div><h4 id="org8b3cc51"><span class="section-number-4">1.3.1</span> Graph with weights</h4><p>A regular graph tells me the <code>neighbors</code> of each node. A <i>weighted</i> graph also tells me the cost of moving along each edge. I’m going to add a <code>cost(from_node, to_node)</code> function that tells us the cost of moving from location <code>from_node</code> to its neighbor <code>to_node</code>. In this forest map I chose to make movement depend only on <code>to_node</code>, but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement that use both nodes</a><sup class="print-endnote">[1]</sup>. An alternate implementation would be to merge this into the <code>neighbors</code> function.</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">class</span> <span class="type">GridWithWeights</span><span class="paren">(</span>SquareGrid<span class="paren">)</span>:
    <span class="minor-control-construct">def</span> <span class="function-name">__init__</span><span class="paren">(</span><span class="keyword">self</span>, width, height<span class="paren">)</span>:
        <span class="builtin">super</span><span class="paren">()</span>.__init__<span class="paren">(</span>width, height<span class="paren">)</span>
        <span class="keyword">self</span>.weights = <span class="paren">{}</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">cost</span><span class="paren">(</span><span class="keyword">self</span>, <span class="minor-control-construct">from</span>_node, to_node<span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="keyword">self</span>.weights.get<span class="paren">(</span>to_node, <span class="constant">1</span><span class="paren">)</span>
</pre></div><h4 id="org9f0e35a"><span class="section-number-4">1.3.2</span> Queue with priorities</h4><p>A priority queue associates with each item a number called a “priority”. When returning an item, it picks the one with the lowest number.</p><dl class="org-dl"><dt>insert</dt><dd>Add item to queue</dd><dt>remove</dt><dd>Remove item with the lowest number</dd><dt>reprioritize</dt><dd>(optional) Change an existing item’s priority to a lower number</dd></dl><p>Here’s a reasonably fast priority queue that uses <i>binary heaps</i>, but does not support reprioritize. To get the right ordering, we’ll use tuples (priority, item). When an element is inserted that is already in the queue, we’ll have a duplicate; I’ll explain why that’s ok in the Optimization section.</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">import</span> heapq

<span class="minor-control-construct">class</span> <span class="type">PriorityQueue</span>:
    <span class="minor-control-construct">def</span> <span class="function-name">__init__</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="keyword">self</span>.elements = <span class="paren">[]</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">empty</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> <span class="builtin">len</span><span class="paren">(</span><span class="keyword">self</span>.elements<span class="paren">)</span> == <span class="constant">0</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">put</span><span class="paren">(</span><span class="keyword">self</span>, item, priority<span class="paren">)</span>:
        heapq.heappush<span class="paren">(</span><span class="keyword">self</span>.elements, <span class="paren">(</span>priority, item<span class="paren">))</span>
    
    <span class="minor-control-construct">def</span> <span class="function-name">get</span><span class="paren">(</span><span class="keyword">self</span><span class="paren">)</span>:
        <span class="major-control-construct">return</span> heapq.heappop<span class="paren">(</span><span class="keyword">self</span>.elements<span class="paren">)[</span><span class="constant">1</span><span class="paren">]</span>
</pre></div><h4 id="org2e59819"><span class="section-number-4">1.3.3</span> Search</h4><p>Here’s a tricky bit about the implementation: once we add movement costs it’s possible to visit a location again, with a better <code>cost_so_far</code>. That means the line <code>if next not in came_from</code> won’t work. Instead, have to check if the cost has gone down since the last time we visited. (In the original version of the article I wasn’t checking this, but my code worked anyway; <a href="https://www.redblobgames.com/pathfinding/posts/reprioritize.html">I wrote some notes about that bug</a>.)</p><p>This forest map is from <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html#dijkstra">the main page</a>.</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">def</span> <span class="function-name">dijkstra_search</span><span class="paren">(</span>graph, start, goal<span class="paren">)</span>:
    <span class="variable-name">frontier</span> = PriorityQueue<span class="paren">()</span>
    frontier.put<span class="paren">(</span>start, <span class="constant">0</span><span class="paren">)</span>
    came_<span class="minor-control-construct">from</span> = <span class="paren">{}</span>
    <span class="variable-name">cost_so_far</span> = <span class="paren">{}</span>
    came_<span class="minor-control-construct">from</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">None</span>
    <span class="variable-name">cost_so_far</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">0</span>
    
    <span class="minor-control-construct">while</span> <span class="keyword">not</span> frontier.empty<span class="paren">()</span>:
        <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>
        
        <span class="minor-control-construct">if</span> current == goal:
            <span class="major-control-construct">break</span>
        
        <span class="minor-control-construct">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors<span class="paren">(</span>current<span class="paren">)</span>:
            <span class="variable-name">new_cost</span> = cost_so_far<span class="paren">[</span>current<span class="paren">]</span> + graph.cost<span class="paren">(</span>current, <span class="builtin">next</span><span class="paren">)</span>
            <span class="minor-control-construct">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far<span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span>:
                <span class="variable-name">cost_so_far</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = new_cost
                <span class="variable-name">priority</span> = new_cost
                frontier.put<span class="paren">(</span><span class="builtin">next</span>, priority<span class="paren">)</span>
                came_<span class="minor-control-construct">from</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = current
    
    <span class="major-control-construct">return</span> came_<span class="minor-control-construct">from</span>, cost_so_far
</pre></div><p>Finally, after searching I need to build the path:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">def</span> <span class="function-name">reconstruct_path</span><span class="paren">(</span>came_<span class="minor-control-construct">from</span>, start, goal<span class="paren">)</span>:
    <span class="variable-name">current</span> = goal
    <span class="variable-name">path</span> = <span class="paren">[]</span>
    <span class="minor-control-construct">while</span> current != start:
        path.append<span class="paren">(</span>current<span class="paren">)</span>
        <span class="variable-name">current</span> = came_<span class="minor-control-construct">from</span><span class="paren">[</span>current<span class="paren">]</span>
    path.append<span class="paren">(</span>start<span class="paren">)</span> <span class="comment-delimiter"># </span><span class="comment">optional</span>
    path.reverse<span class="paren">()</span> <span class="comment-delimiter"># </span><span class="comment">optional</span>
    <span class="major-control-construct">return</span> path
</pre></div><p>Although paths are best thought of as a sequence of edges, it’s convenient to store them as a sequence of nodes. To build the path, start at the end and follow the <code>came_from</code> map, which points to the previous node. When we reach start, we’re done. It is the <b>backwards</b> path, so call <code>reverse()</code> at the end of <code>reconstruct_path</code> if you need it to be stored forwards. Sometimes it’s actually more convenient to store it backwards. Sometimes it’s useful to also store the start node in the list.</p><p>Let’s try it out:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *
came_<span class="minor-control-construct">from</span>, <span class="variable-name">cost_so_far</span> = dijkstra_search<span class="paren">(</span>diagram4, <span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>, <span class="paren">(</span><span class="constant">7</span>, <span class="constant">8</span><span class="paren">))</span>
draw_grid<span class="paren">(</span>diagram4, width=<span class="constant">3</span>, point_to=came_<span class="minor-control-construct">from</span>, start=<span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>, goal=<span class="paren">(</span><span class="constant">7</span>, <span class="constant">8</span><span class="paren">))</span>
<span class="keyword">print</span><span class="paren">()</span>
draw_grid<span class="paren">(</span>diagram4, width=<span class="constant">3</span>, number=cost_so_far, start=<span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>, goal=<span class="paren">(</span><span class="constant">7</span>, <span class="constant">8</span><span class="paren">))</span>
<span class="keyword">print</span><span class="paren">()</span>
draw_grid<span class="paren">(</span>diagram4, width=<span class="constant">3</span>, path=reconstruct_path<span class="paren">(</span>came_<span class="minor-control-construct">from</span>, start=<span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>, goal=<span class="paren">(</span><span class="constant">7</span>, <span class="constant">8</span><span class="paren">)))</span>
</pre></div><pre class="example">v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  
v  v  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt;  &lt;  
v  v  &lt;  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt;  
v  v  &lt;  &lt;  &lt;  &lt;  &lt;  ^  ^  .  
&gt;  A  &lt;  &lt;  &lt;  &lt;  .  .  .  .  
^  ^  &lt;  &lt;  &lt;  &lt;  .  .  .  .  
^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  .  
^  #########^  &lt;  v  .  .  .  
^  #########v  v  v  Z  .  .  
^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  

5  4  5  6  7  8  9  10 11 12 
4  3  4  5  10 13 10 11 12 13 
3  2  3  4  9  14 15 12 13 14 
2  1  2  3  8  13 18 17 14 .  
1  A  1  6  11 16 .  .  .  .  
2  1  2  7  12 17 .  .  .  .  
3  2  3  4  9  14 19 .  .  .  
4  #########14 19 18 .  .  .  
5  #########15 16 13 Z  .  .  
6  7  8  9  10 11 12 13 14 .  

.  .  .  .  .  .  .  .  .  .  
.  .  .  .  .  .  .  .  .  .  
.  .  .  .  .  .  .  .  .  .  
.  .  .  .  .  .  .  .  .  .  
@  @  .  .  .  .  .  .  .  .  
@  .  .  .  .  .  .  .  .  .  
@  .  .  .  .  .  .  .  .  .  
@  #########.  .  .  .  .  .  
@  #########.  .  @  @  .  .  
@  @  @  @  @  @  @  .  .  .  
</pre><p>The line <code>if next not in cost_so_far or new_cost &lt; cost_so_far[next]</code> could be simplified to <code>if new_cost &lt; cost_so_far.get(next, Infinity)</code> but I didn’t want to explain Python’s <code>get()</code> in the main article so I left it as is. Another approach would be to use <code>collections.defaultdict</code> defaulting to infinity.</p><h3 id="python-astar"><span class="section-number">&nbsp;1.4&nbsp;</span><span>A* Search</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#python-astar">#</a></h3><div class="outline-text-3" id="text-python-astar"><p>Both Greedy Best-First Search and A* use a heuristic function. The only difference is that A* uses both the heuristic and the ordering from Dijkstra’s Algorithm. I’m going to show A* here.</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">def</span> <span class="function-name">heuristic</span><span class="paren">(</span>a, b<span class="paren">)</span>:
    <span class="paren">(</span>x1, y1<span class="paren">)</span> = a
    <span class="paren">(</span>x2, y2<span class="paren">)</span> = b
    <span class="major-control-construct">return</span> <span class="builtin">abs</span><span class="paren">(</span>x1 - x2<span class="paren">)</span> + <span class="builtin">abs</span><span class="paren">(</span>y1 - y2<span class="paren">)</span>

<span class="minor-control-construct">def</span> <span class="function-name">a_star_search</span><span class="paren">(</span>graph, start, goal<span class="paren">)</span>:
    <span class="variable-name">frontier</span> = PriorityQueue<span class="paren">()</span>
    frontier.put<span class="paren">(</span>start, <span class="constant">0</span><span class="paren">)</span>
    came_<span class="minor-control-construct">from</span> = <span class="paren">{}</span>
    <span class="variable-name">cost_so_far</span> = <span class="paren">{}</span>
    came_<span class="minor-control-construct">from</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">None</span>
    <span class="variable-name">cost_so_far</span><span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">0</span>
    
    <span class="minor-control-construct">while</span> <span class="keyword">not</span> frontier.empty<span class="paren">()</span>:
        <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>
        
        <span class="minor-control-construct">if</span> current == goal:
            <span class="major-control-construct">break</span>
        
        <span class="minor-control-construct">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors<span class="paren">(</span>current<span class="paren">)</span>:
            <span class="variable-name">new_cost</span> = cost_so_far<span class="paren">[</span>current<span class="paren">]</span> + graph.cost<span class="paren">(</span>current, <span class="builtin">next</span><span class="paren">)</span>
            <span class="minor-control-construct">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far<span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span>:
                <span class="variable-name">cost_so_far</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = new_cost
                <span class="variable-name">priority</span> = new_cost + heuristic<span class="paren">(</span>goal, <span class="builtin">next</span><span class="paren">)</span>
                frontier.put<span class="paren">(</span><span class="builtin">next</span>, priority<span class="paren">)</span>
                came_<span class="minor-control-construct">from</span><span class="paren">[</span><span class="builtin">next</span><span class="paren">]</span> = current
    
    <span class="major-control-construct">return</span> came_<span class="minor-control-construct">from</span>, cost_so_far
</pre></div><p>Let’s try it out:</p><div class="org-src-container"><pre class="src src-python"><span class="minor-control-construct">from</span> implementation <span class="minor-control-construct">import</span> *
<span class="variable-name">start</span>, <span class="variable-name">goal</span> = <span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>, <span class="paren">(</span><span class="constant">7</span>, <span class="constant">8</span><span class="paren">)</span>
came_<span class="minor-control-construct">from</span>, <span class="variable-name">cost_so_far</span> = a_star_search<span class="paren">(</span>diagram4, start, goal<span class="paren">)</span>
draw_grid<span class="paren">(</span>diagram4, width=<span class="constant">3</span>, point_to=came_<span class="minor-control-construct">from</span>, start=start, goal=goal<span class="paren">)</span>
<span class="keyword">print</span><span class="paren">()</span>
draw_grid<span class="paren">(</span>diagram4, width=<span class="constant">3</span>, number=cost_so_far, start=start, goal=goal<span class="paren">)</span>
<span class="keyword">print</span><span class="paren">()</span>
</pre></div><pre class="example">.  .  .  .  .  .  .  .  .  .  
.  v  v  v  .  .  .  .  .  .  
v  v  v  v  &lt;  .  .  .  .  .  
v  v  v  &lt;  &lt;  .  .  .  .  .  
&gt;  A  &lt;  &lt;  &lt;  .  .  .  .  .  
&gt;  ^  &lt;  &lt;  &lt;  .  .  .  .  .  
&gt;  ^  &lt;  &lt;  &lt;  &lt;  .  .  .  .  
^  #########^  .  v  .  .  .  
^  #########v  v  v  Z  .  .  
^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  

.  .  .  .  .  .  .  .  .  .  
.  3  4  5  .  .  .  .  .  .  
3  2  3  4  9  .  .  .  .  .  
2  1  2  3  8  .  .  .  .  .  
1  A  1  6  11 .  .  .  .  .  
2  1  2  7  12 .  .  .  .  .  
3  2  3  4  9  14 .  .  .  .  
4  #########14 .  18 .  .  .  
5  #########15 16 13 Z  .  .  
6  7  8  9  10 11 12 13 .  .  </pre></div><h4 id="org519e991"><span class="section-number-4">1.4.1</span> Straighter paths</h4><p>If you implement this code in your own project you might find that some of the paths aren’t as “straight” as you’d like. <b>This is normal</b>. When using <i>grids</i>, especially grids where every step has the same movement cost, you end up with <b>ties</b>: many paths have exactly the same cost. A* ends up picking one of the many short paths, and very often <b>it doesn’t look good to you</b>. The quick hack is to <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties">break the ties</a><sup class="print-endnote">[2]</sup>, but it’s not entirely satisfactory. The better approach is to <a href="https://www.redblobgames.com/pathfinding/grids/algorithms.html">change the map representation</a>, which makes A* a lot faster, and also produces straighter, better looking paths. However, that only works for mostly-static maps where every step has the same movement cost. For the demos on my page, I’m using a quick hack, but it only works with my slow priority queue. If you switch to a faster priority queue you’ll need a different quick hack.</p></section><section><h2 id="cplusplus"><span class="section-number">&nbsp;2&nbsp; </span><span>C++ Implementation</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cplusplus">#</a></h2><div class="outline-text-2" id="text-cplusplus"><p>Note: some of the sample code needs to include <a href="https://www.redblobgames.com/pathfinding/a-star/implementation.cpp">redblobgames/pathfinding/a-star/implementation.cpp</a> to run. I am using <b>C++11</b> for this code so some of it will need to be changed if you use an older version of the C++ standard.</p><p><i>The code here is meant for the tutorial and is not production-quality</i>; there’s a section at the end with tips on making it better.</p></div><h3 id="cpp-breadth-first"><span class="section-number">&nbsp;2.1&nbsp;</span><span>Breadth First Search</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-breadth-first">#</a></h3><p>Let’s implement Breadth First Search in C++. These are the components we need:</p><dl class="org-dl"><dt>Graph</dt><dd>a data structure that can tell me the <code>neighbors</code> for each location (see <a href="https://www.redblobgames.com/pathfinding/grids/graphs.html">this tutorial</a>).. A <i>weighted</i> graph can also tell me the <code>cost</code> of moving along an edge.</dd><dt>Locations</dt><dd>a simple value (int, string, tuple, etc.) that <i>labels</i> locations in the graph</dd><dt>Search</dt><dd>an algorithm that takes a graph, a starting location, and optionally a goal location, and calculates some useful information (visited, parent pointer, distance) for some or all locations</dd><dt>Queue</dt><dd>a data structure used by the search algorithm to decide the order in which to process the locations</dd></dl><p>In the main article, I focused on <b>search</b>. On this page, I’ll fill in the rest of the details to make complete working programs. Let’s start with a <b>graph</b> where the labels are <code>char</code>:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">SimpleGraph</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">char</span>, <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">char</span>&gt; &gt; <span class="variable-name">edges</span>;

  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">char</span>&gt; <span class="function-name">neighbors</span><span class="paren">(</span><span class="type">char</span> <span class="variable-name">id</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="major-control-construct">return</span> edges<span class="paren">[</span>id<span class="paren">]</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>;
</pre></div><p>Here’s an example:</p><div class="figure"><p><img src="./Implementation of A__files/implementation-example-graph.png" alt="implementation-example-graph.png"></p></div><div class="org-src-container"><pre class="src src-cpp"><span class="type">SimpleGraph</span> <span class="variable-name">example_graph</span> <span class="minor-control-construct"><span class="paren">{{</span></span>
    <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'A'</span>, <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'B'</span><span class="minor-control-construct"><span class="paren">}}</span></span>,
    <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'B'</span>, <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'D'</span><span class="minor-control-construct"><span class="paren">}}</span></span>,
    <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'C'</span>, <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'A'</span><span class="minor-control-construct"><span class="paren">}}</span></span>,
    <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'D'</span>, <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'E'</span>, <span class="string">'A'</span><span class="minor-control-construct"><span class="paren">}}</span></span>,
    <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'E'</span>, <span class="minor-control-construct"><span class="paren">{</span></span><span class="string">'B'</span><span class="minor-control-construct"><span class="paren">}}</span></span>
  <span class="minor-control-construct"><span class="paren">}}</span></span>;
</pre></div><p>The C++ standard library already includes a queue class. We now have a graph (<code>SimpleGraph</code>), locations (<code>char</code>), and a queue (<code>std::queue</code>). Now we can try Breadth First Search:</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">void</span> <span class="function-name">breadth_first_search</span><span class="paren">(</span><span class="type">SimpleGraph</span> <span class="variable-name">graph</span>, <span class="type">char</span> <span class="variable-name">start</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">char</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push<span class="paren">(</span>start<span class="paren">)</span>;

  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;<span class="type">char</span>&gt; <span class="variable-name">visited</span>;
  visited.insert<span class="paren">(</span>start<span class="paren">)</span>;

  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">char</span> <span class="variable-name">current</span> = frontier.front<span class="paren">()</span>;
    frontier.pop<span class="paren">()</span>;

    <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Visiting "</span> &lt;&lt; current &lt;&lt; <span class="string">'\n'</span>;
    <span class="keyword">for</span> <span class="paren">(</span><span class="type">char</span> <span class="variable-name">next</span> : graph.neighbors<span class="paren">(</span>current<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="keyword">if</span> <span class="paren">(</span>visited.find<span class="paren">(</span>next<span class="paren">)</span> == visited.end<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        frontier.push<span class="paren">(</span>next<span class="paren">)</span>;
        visited.insert<span class="paren">(</span>next<span class="paren">)</span>;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>


<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  breadth_first_search<span class="paren">(</span>example_graph, <span class="string">'A'</span><span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">Visiting A
Visiting B
Visiting C
Visiting D
Visiting E
</pre><p>How about square grids? This time, locations will be labeled with x,y, and I’ll make another graph class that keeps track of the walls in the grid:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">GridLocation</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">int</span> <span class="variable-name">x</span>, <span class="variable-name">y</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>;

<span class="keyword">namespace</span> <span class="constant">std</span> <span class="minor-control-construct"><span class="paren">{</span></span>
<span class="comment-delimiter">/* </span><span class="comment">implement hash function so we can put GridLocation into an unordered_set */</span>
<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="type">hash</span>&lt;<span class="type">GridLocation</span>&gt; <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="keyword">typedef</span> <span class="type">GridLocation</span> <span class="type">argument_type</span>;
  <span class="keyword">typedef</span> <span class="constant">std</span>::<span class="type">size_t</span> <span class="type">result_type</span>;
  <span class="constant">std</span>::<span class="type">size_t</span> <span class="keyword">operator</span><span class="paren">()(</span><span class="keyword">const</span> <span class="type">GridLocation</span>&amp; <span class="variable-name">id</span><span class="paren">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="major-control-construct">return</span> <span class="constant">std</span>::hash&lt;<span class="type">int</span>&gt;<span class="paren">()(</span>id.x ^ <span class="paren">(</span>id.y &lt;&lt; <span class="constant">4</span><span class="paren">))</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>;
<span class="minor-control-construct"><span class="paren">}</span></span>


<span class="keyword">struct</span> <span class="type">SquareGrid</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="keyword">static</span> <span class="constant">std</span>::<span class="type">array</span>&lt;<span class="type">GridLocation</span>, <span class="constant">4</span>&gt; <span class="variable-name">DIRS</span>;

  <span class="type">int</span> <span class="variable-name">width</span>, <span class="variable-name">height</span>;
  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">walls</span>;

  <span class="function-name">SquareGrid</span><span class="paren">(</span><span class="type">int</span> <span class="variable-name">width_</span>, <span class="type">int</span> <span class="variable-name">height_</span><span class="paren">)</span>
     : width<span class="paren">(</span>width_<span class="paren">)</span>, height<span class="paren">(</span>height_<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{}</span></span>

  <span class="type">bool</span> <span class="function-name">in_bounds</span><span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">id</span><span class="paren">)</span> <span class="keyword">const</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="major-control-construct">return</span> <span class="constant">0</span> &lt;= id.x &amp;&amp; id.x &lt; width
        &amp;&amp; <span class="constant">0</span> &lt;= id.y &amp;&amp; id.y &lt; height;
  <span class="minor-control-construct"><span class="paren">}</span></span>

  <span class="type">bool</span> <span class="function-name">passable</span><span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">id</span><span class="paren">)</span> <span class="keyword">const</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="major-control-construct">return</span> walls.find<span class="paren">(</span>id<span class="paren">)</span> == walls.end<span class="paren">()</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>

  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="function-name">neighbors</span><span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">id</span><span class="paren">)</span> <span class="keyword">const</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">results</span>;

    <span class="keyword">for</span> <span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">dir</span> : DIRS<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="type">GridLocation</span> <span class="variable-name">next</span><span class="minor-control-construct"><span class="paren">{</span></span>id.x + dir.x, id.y + dir.y<span class="minor-control-construct"><span class="paren">}</span></span>;
      <span class="keyword">if</span> <span class="paren">(</span>in_bounds<span class="paren">(</span>next<span class="paren">)</span> &amp;&amp; passable<span class="paren">(</span>next<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        results.push_back<span class="paren">(</span>next<span class="paren">)</span>;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>

    <span class="keyword">if</span> <span class="paren">((</span>id.x + id.y<span class="paren">)</span> % <span class="constant">2</span> == <span class="constant">0</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="comment-delimiter">// </span><span class="comment">aesthetic improvement on square grids</span>
      <span class="constant">std</span>::reverse<span class="paren">(</span>results.begin<span class="paren">()</span>, results.end<span class="paren">())</span>;
    <span class="minor-control-construct"><span class="paren">}</span></span>

    <span class="major-control-construct">return</span> results;
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>;

<span class="constant">std</span>::<span class="type">array</span>&lt;<span class="type">GridLocation</span>, <span class="constant">4</span>&gt; <span class="constant">SquareGrid</span>::<span class="variable-name">DIRS</span> =
  <span class="minor-control-construct"><span class="paren">{</span></span>GridLocation<span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">1</span>, <span class="constant">0</span><span class="minor-control-construct"><span class="paren">}</span></span>, GridLocation<span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">0</span>, -<span class="constant">1</span><span class="minor-control-construct"><span class="paren">}</span></span>, GridLocation<span class="minor-control-construct"><span class="paren">{</span></span>-<span class="constant">1</span>, <span class="constant">0</span><span class="minor-control-construct"><span class="paren">}</span></span>, GridLocation<span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">0</span>, <span class="constant">1</span><span class="minor-control-construct"><span class="paren">}}</span></span>;
</pre></div><p>In the helper file <code>implementation.cpp</code> I defined a function to make grids:</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1<span class="paren">()</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">2</span><span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . 
. . . ####. . . . . . . . . . . . . . . . ####. . . . . . . 
. . . ####. . . . . . . . ####. . . . . . ####. . . . . . . 
. . . ####. . . . . . . . ####. . . . . . ##########. . . . 
. . . ####. . . . . . . . ####. . . . . . ##########. . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . ####. . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . . 
. . . . . . . . . . . . . ####. . . . . . . . . . . . . . .
</pre><p>Let’s try Breadth First Search again, keeping track of <code>came_from</code>:</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;
<span class="function-name">breadth_first_search</span><span class="paren">(</span><span class="type">Graph</span> <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push<span class="paren">(</span>start<span class="paren">)</span>;

  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>;
  came_from<span class="paren">[</span>start<span class="paren">]</span> = start;

  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.front<span class="paren">()</span>;
    frontier.pop<span class="paren">()</span>;

    <span class="keyword">for</span> <span class="paren">(</span><span class="type">Location</span> <span class="variable-name">next</span> : graph.neighbors<span class="paren">(</span>current<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="keyword">if</span> <span class="paren">(</span>came_from.find<span class="paren">(</span>next<span class="paren">)</span> == came_from.end<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        frontier.push<span class="paren">(</span>next<span class="paren">)</span>;
        came_from<span class="paren">[</span>next<span class="paren">]</span> = current;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="major-control-construct">return</span> came_from;
<span class="minor-control-construct"><span class="paren">}</span></span>

<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1<span class="paren">()</span>;
  <span class="type">auto</span> <span class="variable-name">parents</span> = breadth_first_search<span class="paren">(</span>grid, GridLocation<span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">7</span>, <span class="constant">8</span><span class="minor-control-construct"><span class="paren">}</span></span><span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">2</span>, <span class="constant">nullptr</span>, &amp;parents<span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">&gt; &gt; &gt; &gt; v v v v v v v v v v v v &lt; &lt; &lt; &lt; &lt; ####v v v v v v v 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; ####v v v v v v v 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; &lt; ####&gt; v v v v v v 
&gt; &gt; ^ ####v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; ####&gt; &gt; v v v v v 
&gt; ^ ^ ####v v v v v v v &lt; ####^ &lt; &lt; &lt; &lt; &lt; ####&gt; &gt; &gt; v v v v 
^ ^ ^ ####v v v v v v &lt; &lt; ####^ ^ &lt; &lt; &lt; &lt; ##########v v v &lt; 
^ ^ ^ ####&gt; v v v v &lt; &lt; &lt; ####^ ^ ^ &lt; &lt; &lt; ##########v v &lt; &lt; 
v v v ####&gt; &gt; v v &lt; &lt; &lt; &lt; ####^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####&gt; &gt; * &lt; &lt; &lt; &lt; &lt; ####^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####&gt; ^ ^ ^ &lt; &lt; &lt; &lt; ####^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v v ####^ ^ ^ ^ ^ &lt; &lt; &lt; ####^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; v v ####^ ^ ^ ^ ^ ^ &lt; &lt; ####^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ &lt; ####^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt; &lt; 
&gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ####^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ &lt; &lt; &lt; &lt;
</pre><p>Some implementations use <i>internal storage</i>, creating a Node object to hold <code>came_from</code> and other values for each graph node. I’ve instead chosen to use <i>external storage</i>, creating a single <code>std::unordered_map</code> to store the <code>came_from</code> for all graph nodes. If you know your map locations have integer indices, another option is to use a 1D or 2D array/vector to store <code>came_from</code> and other values.</p><h3 id="cpp-early-exit"><span class="section-number">&nbsp;2.2&nbsp;</span><span>Early Exit</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-early-exit">#</a></h3><p>Breadth First Search and Dijkstra’s Algorithm will explore the entire map by default. If we’re looking for a path to a single, point we can add <kbd>if (current == goal)</kbd> to exit the loop as soon as we find the path.</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;
<span class="function-name">breadth_first_search</span><span class="paren">(</span><span class="type">Graph</span> <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push<span class="paren">(</span>start<span class="paren">)</span>;

  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>;
  came_from<span class="paren">[</span>start<span class="paren">]</span> = start;

  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.front<span class="paren">()</span>;
    frontier.pop<span class="paren">()</span>;

    <span class="keyword">if</span> <span class="paren">(</span>current == goal<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="major-control-construct">break</span>;
    <span class="minor-control-construct"><span class="paren">}</span></span>
    
    <span class="keyword">for</span> <span class="paren">(</span><span class="type">Location</span> <span class="variable-name">next</span> : graph.neighbors<span class="paren">(</span>current<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="keyword">if</span> <span class="paren">(</span>came_from.find<span class="paren">(</span>next<span class="paren">)</span> == came_from.end<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        frontier.push<span class="paren">(</span>next<span class="paren">)</span>;
        came_from<span class="paren">[</span>next<span class="paren">]</span> = current;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="major-control-construct">return</span> came_from;
<span class="minor-control-construct"><span class="paren">}</span></span>

<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">GridLocation</span> <span class="variable-name">start</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">8</span>, <span class="constant">7</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="type">GridLocation</span> <span class="variable-name">goal</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">17</span>, <span class="constant">2</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1<span class="paren">()</span>;
  <span class="type">auto</span> <span class="variable-name">came_from</span> = breadth_first_search<span class="paren">(</span>grid, start, goal<span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">2</span>, <span class="constant">nullptr</span>, &amp;came_from<span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">. &gt; &gt; &gt; v v v v v v v v v v v v &lt; . . . . ####. . . . . . . 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v v &lt; &lt; &lt; . . . ####. . . . . . . 
&gt; &gt; &gt; &gt; &gt; v v v v v v v v v &lt; &lt; &lt; &lt; . . . ####. . . . . . . 
&gt; &gt; ^ ####v v v v v v v v &lt; &lt; &lt; &lt; &lt; &lt; . . ####. . . . . . . 
. ^ ^ ####&gt; v v v v v v &lt; ####^ &lt; &lt; . . . ####. . . . . . . 
. . ^ ####&gt; &gt; v v v v &lt; &lt; ####^ ^ . . . . ##########. . . . 
. . . ####&gt; &gt; &gt; v v &lt; &lt; &lt; ####^ . . . . . ##########. . . . 
. . . ####&gt; &gt; &gt; * &lt; &lt; &lt; &lt; ####. . . . . . . . . . . . . . . 
. . . ####&gt; &gt; ^ ^ ^ &lt; &lt; &lt; ####. . . . . . . . . . . . . . . 
. . v ####&gt; ^ ^ ^ ^ ^ &lt; &lt; ####. . . . . . . . . . . . . . . 
. v v ####^ ^ ^ ^ ^ ^ ^ &lt; ####. . . . . . . . . . . . . . . 
&gt; v v ####^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
&gt; &gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
&gt; &gt; &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . . 
. &gt; &gt; ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ####. . . . . . . . . . . . . . .
</pre><p>In the output we can see that the algorithm did not explore the entire map, but stopped early.</p><h3 id="cpp-dijkstra"><span class="section-number">&nbsp;2.3&nbsp;</span><span>Dijkstra’s Algorithm</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-dijkstra">#</a></h3><div class="outline-text-3" id="text-cpp-dijkstra"><p>This is what adds complexity to graph search, because we’re going to start processing locations in a better order than “first in, first out”. What do we need to change?</p><ol class="org-ol"><li>The <i>graph</i> needs to know cost of movement.</li><li>The <i>queue</i> needs to return nodes in a different order.</li><li>The <i>search</i> needs to keep track of these costs from the graph and give them to the queue.</li></ol></div><h4 id="orge461572"><span class="section-number-4">2.3.1</span> Graph with weights</h4><p>A regular graph tells me the <code>neighbors</code> of each node. A <i>weighted</i> graph also tells me the cost of moving along each edge. I’m going to add a <code>cost(from_node, to_node)</code> function that tells us the cost of moving from location <code>from_node</code> to its neighbor <code>to_node</code>. In this forest map I chose to make movement depend only on <code>to_node</code>, but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement that use both nodes</a><sup class="print-endnote">[3]</sup>. An alternate implementation would be to merge this into the <code>neighbors</code> function. Here’s a grid with a list of forest tiles, which will have movement cost 5:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">GridWithWeights</span>: <span class="type">SquareGrid</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;GridLocation&gt; <span class="variable-name">forests</span>;
  <span class="function-name">GridWithWeights</span><span class="paren">(</span><span class="type">int</span> <span class="variable-name">w</span>, <span class="type">int</span> <span class="variable-name">h</span><span class="paren">)</span>: <span class="function-name">SquareGrid</span><span class="paren">(</span>w, h<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{}</span></span>
  <span class="type">double</span> <span class="function-name">cost</span><span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">from_node</span>, <span class="type">GridLocation</span> <span class="variable-name">to_node</span><span class="paren">)</span> <span class="keyword">const</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="major-control-construct">return</span> forests.find<span class="paren">(</span>to_node<span class="paren">)</span> != forests.end<span class="paren">()</span>? <span class="constant">5</span> : <span class="constant">1</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>;
</pre></div><h4 id="orgfc6a236"><span class="section-number-4">2.3.2</span> Queue with priorities</h4><p>We need a priority queue. C++ offers a <code>priority_queue</code> class that uses a binary heap but not the reprioritize operation. I’ll use a pair (priority, item) for the queue elements to get the right ordering. By default, the C++ priority queue returns the maximum element first, using the <code>std::less</code> comparator; we want the minimum element instead, so I’ll use the <code>std::greater</code> comparator.</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>, <span class="keyword">typename</span> <span class="type">priority_t</span>&gt;
<span class="keyword">struct</span> <span class="type">PriorityQueue</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="keyword">typedef</span> <span class="constant">std</span>::<span class="type">pair</span>&lt;<span class="type">priority_t</span>, <span class="type">T</span>&gt; <span class="type">PQElement</span>;
  <span class="constant">std</span>::<span class="type">priority_queue</span>&lt;<span class="type">PQElement</span>, <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">PQElement</span>&gt;,
                 <span class="constant">std</span>::<span class="type">greater</span>&lt;<span class="type">PQElement</span>&gt;&gt; <span class="variable-name">elements</span>;

  <span class="keyword">inline</span> <span class="type">bool</span> <span class="function-name">empty</span><span class="paren">()</span> <span class="keyword">const</span> <span class="minor-control-construct"><span class="paren">{</span></span>
     <span class="major-control-construct">return</span> elements.empty<span class="paren">()</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>

  <span class="keyword">inline</span> <span class="type">void</span> <span class="function-name">put</span><span class="paren">(</span><span class="type">T</span> <span class="variable-name">item</span>, <span class="type">priority_t</span> <span class="variable-name">priority</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    elements.emplace<span class="paren">(</span>priority, item<span class="paren">)</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>

  <span class="type">T</span> <span class="function-name">get</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">T</span> <span class="variable-name">best_item</span> = elements.top<span class="paren">()</span>.second;
    elements.pop<span class="paren">()</span>;
    <span class="major-control-construct">return</span> best_item;
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>;
</pre></div><p>In this sample code I’m wrapping the C++ <code>std::priority_queue</code> class but I think it’d be reasonable to use that class directly without the wrapper.</p><h4 id="org095fdfb"><span class="section-number-4">2.3.3</span> Search</h4><p>See <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html#dijkstra">the forest map from the main page</a>.</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">dijkstra_search</span>
  <span class="paren">(</span><span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;&amp; <span class="variable-name">cost_so_far</span><span class="paren">)</span>
<span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">frontier</span>;
  frontier.put<span class="paren">(</span>start, <span class="constant">0</span><span class="paren">)</span>;

  came_from<span class="paren">[</span>start<span class="paren">]</span> = start;
  cost_so_far<span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">0</span>;
  
  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>;

    <span class="keyword">if</span> <span class="paren">(</span>current == goal<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="major-control-construct">break</span>;
    <span class="minor-control-construct"><span class="paren">}</span></span>

    <span class="keyword">for</span> <span class="paren">(</span><span class="type">Location</span> <span class="variable-name">next</span> : graph.neighbors<span class="paren">(</span>current<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="type">double</span> <span class="variable-name">new_cost</span> = cost_so_far<span class="paren">[</span>current<span class="paren">]</span> + graph.cost<span class="paren">(</span>current, next<span class="paren">)</span>;
      <span class="keyword">if</span> <span class="paren">(</span>cost_so_far.find<span class="paren">(</span>next<span class="paren">)</span> == cost_so_far.end<span class="paren">()</span>
          || new_cost &lt; cost_so_far<span class="paren">[</span>next<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        cost_so_far<span class="paren">[</span>next<span class="paren">]</span> = new_cost;
        came_from<span class="paren">[</span>next<span class="paren">]</span> = current;
        frontier.put<span class="paren">(</span>next, new_cost<span class="paren">)</span>;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><p>The types of the <code>cost</code> variables should all match the types used in the graph. If you use <code>int</code> then you can use <code>int</code> for the cost variable and the priorities in the priority queue; if you use <code>double</code> then you should use <code>double</code> for these. In this code I used <code>double</code> but I could’ve used <code>int</code> and it would’ve worked the same. However, if your graph edge costs are doubles or if your heuristic uses doubles, then you’ll need to use doubles here.</p><p>Finally, after searching I need to build the path:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>&gt;
<span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">reconstruct_path</span><span class="paren">(</span>
   <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>
<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">path</span>;
  <span class="type">Location</span> <span class="variable-name">current</span> = goal;
  <span class="keyword">while</span> <span class="paren">(</span>current != start<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    path.push_back<span class="paren">(</span>current<span class="paren">)</span>;
    current = came_from<span class="paren">[</span>current<span class="paren">]</span>;
  <span class="minor-control-construct"><span class="paren">}</span></span>
  path.push_back<span class="paren">(</span>start<span class="paren">)</span>; <span class="comment-delimiter">// </span><span class="comment">optional</span>
  <span class="constant">std</span>::reverse<span class="paren">(</span>path.begin<span class="paren">()</span>, path.end<span class="paren">())</span>;
  <span class="major-control-construct">return</span> path;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><p>Although paths are best thought of as a sequence of edges, it’s convenient to store them as a sequence of nodes. To build the path, start at the end and follow the <code>came_from</code> map, which points to the previous node. When we reach start, we’re done. It is the <b>backwards</b> path, so call <code>reverse()</code> at the end of <code>reconstruct_path</code> if you need it to be stored forwards. Sometimes it’s actually more convenient to store it backwards. Sometimes it’s useful to also store the start node in the list.</p><p>Let’s try it out:</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram4<span class="paren">()</span>;
  <span class="type">GridLocation</span> <span class="variable-name">start</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">1</span>, <span class="constant">4</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="type">GridLocation</span> <span class="variable-name">goal</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">8</span>, <span class="constant">5</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  dijkstra_search<span class="paren">(</span>grid, start, goal, came_from, cost_so_far<span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">2</span>, <span class="constant">nullptr</span>, &amp;came_from<span class="paren">)</span>;
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">3</span>, &amp;cost_so_far, <span class="constant">nullptr</span><span class="paren">)</span>;
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">path</span> = reconstruct_path<span class="paren">(</span>start, goal, came_from<span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">3</span>, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;path<span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">v v &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 
v v &lt; &lt; &lt; ^ ^ &lt; &lt; &lt; 
v v &lt; &lt; &lt; &lt; ^ ^ &lt; &lt; 
v v &lt; &lt; &lt; &lt; &lt; ^ ^ &lt; 
&gt; * &lt; &lt; &lt; &lt; &lt; &gt; ^ &lt; 
^ ^ &lt; &lt; &lt; &lt; . v ^ . 
^ ^ &lt; &lt; &lt; &lt; &lt; v &lt; . 
^ ######^ &lt; v v &lt; . 
^ ######v v v &lt; &lt; &lt; 
^ &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; &lt; 

5  4  5  6  7  8  9  10 11 12 
4  3  4  5  10 13 10 11 12 13 
3  2  3  4  9  14 15 12 13 14 
2  1  2  3  8  13 18 17 14 15 
1  0  1  6  11 16 21 20 15 16 
2  1  2  7  12 17 .  21 16 .  
3  2  3  4  9  14 19 16 17 .  
4  #########14 19 18 15 16 .  
5  #########15 16 13 14 15 16 
6  7  8  9  10 11 12 13 14 15 

.  @  @  @  @  @  @  .  .  .  
.  @  .  .  .  .  @  @  .  .  
.  @  .  .  .  .  .  @  @  .  
.  @  .  .  .  .  .  .  @  .  
.  @  .  .  .  .  .  .  @  .  
.  .  .  .  .  .  .  .  @  .  
.  .  .  .  .  .  .  .  .  .  
.  #########.  .  .  .  .  .  
.  #########.  .  .  .  .  .  
.  .  .  .  .  .  .  .  .  .
</pre><p>The results are not exactly the same as the Python version because I’m using the built-in priority queues in C++ and Python may order equal-valued nodes differently.</p><h3 id="cpp-astar"><span class="section-number">&nbsp;2.4&nbsp;</span><span>A* Search</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-astar">#</a></h3><div class="outline-text-3" id="text-cpp-astar"><p>A* is almost exactly like Dijkstra’s Algorithm, except we add in a heuristic. Note that the code for the algorithm <i>isn’t specific to grids</i>. Knowledge about grids is in the graph class (<code>SquareGrids</code> in this case), the locations (<code>Location</code> struct), and in the <code>heuristic</code> function. Replace those three and you can use the A* algorithm code with any other graph structure.</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">inline</span> <span class="type">double</span> <span class="function-name">heuristic</span><span class="paren">(</span><span class="type">GridLocation</span> <span class="variable-name">a</span>, <span class="type">GridLocation</span> <span class="variable-name">b</span><span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="major-control-construct">return</span> <span class="constant">std</span>::abs<span class="paren">(</span>a.x - b.x<span class="paren">)</span> + <span class="constant">std</span>::abs<span class="paren">(</span>a.y - b.y<span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">a_star_search</span>
  <span class="paren">(</span><span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;&amp; <span class="variable-name">cost_so_far</span><span class="paren">)</span>
<span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">frontier</span>;
  frontier.put<span class="paren">(</span>start, <span class="constant">0</span><span class="paren">)</span>;

  came_from<span class="paren">[</span>start<span class="paren">]</span> = start;
  cost_so_far<span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">0</span>;
  
  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>;

    <span class="keyword">if</span> <span class="paren">(</span>current == goal<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="major-control-construct">break</span>;
    <span class="minor-control-construct"><span class="paren">}</span></span>

    <span class="keyword">for</span> <span class="paren">(</span><span class="type">Location</span> <span class="variable-name">next</span> : graph.neighbors<span class="paren">(</span>current<span class="paren">))</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="type">double</span> <span class="variable-name">new_cost</span> = cost_so_far<span class="paren">[</span>current<span class="paren">]</span> + graph.cost<span class="paren">(</span>current, next<span class="paren">)</span>;
      <span class="keyword">if</span> <span class="paren">(</span>cost_so_far.find<span class="paren">(</span>next<span class="paren">)</span> == cost_so_far.end<span class="paren">()</span>
          || new_cost &lt; cost_so_far<span class="paren">[</span>next<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        cost_so_far<span class="paren">[</span>next<span class="paren">]</span> = new_cost;
        <span class="type">double</span> <span class="variable-name">priority</span> = new_cost + heuristic<span class="paren">(</span>next, goal<span class="paren">)</span>;
        frontier.put<span class="paren">(</span>next, priority<span class="paren">)</span>;
        came_from<span class="paren">[</span>next<span class="paren">]</span> = current;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><p>The type of the <code>priority</code> values including the type used in the priority queue should be big enough to include both the graph costs (<code>cost_t</code>) and the heuristic value. For example, if the graph costs are ints and the heuristic returns a double, then you need the priority queue to accept doubles. In this sample code I use <code>double</code> for all three (cost, heuristic, and priority), but I could’ve used <code>int</code> because my costs and heuristics are integer valued.</p><p>Minor note: It would be more correct to write <code>frontier.put(start, heuristic(start, goal))</code> than <code>frontier.put(start, 0)</code> but it makes no difference here because the start node’s priority doesn’t matter. It is the only node in the priority queue and it is selected and removed before anything else is put in there.</p><div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span><span class="paren">()</span> <span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram4<span class="paren">()</span>;
  <span class="type">GridLocation</span> <span class="variable-name">start</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">1</span>, <span class="constant">4</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="type">GridLocation</span> <span class="variable-name">goal</span><span class="minor-control-construct"><span class="paren">{</span></span><span class="constant">8</span>, <span class="constant">5</span><span class="minor-control-construct"><span class="paren">}</span></span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  a_star_search<span class="paren">(</span>grid, start, goal, came_from, cost_so_far<span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">2</span>, <span class="constant">nullptr</span>, &amp;came_from<span class="paren">)</span>;
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">3</span>, &amp;cost_so_far, <span class="constant">nullptr</span><span class="paren">)</span>;
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">path</span> = reconstruct_path<span class="paren">(</span>start, goal, came_from<span class="paren">)</span>;
  draw_grid<span class="paren">(</span>grid, <span class="constant">3</span>, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;path<span class="paren">)</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><pre class="example">v v v v &lt; &lt; &lt; &lt; &lt; &lt; 
v v v v &lt; ^ ^ &lt; &lt; &lt; 
v v v v &lt; &lt; ^ ^ &lt; &lt; 
v v v &lt; &lt; &lt; . ^ ^ &lt; 
&gt; * &lt; &lt; &lt; &lt; . &gt; ^ &lt; 
&gt; ^ &lt; &lt; &lt; &lt; . . ^ . 
^ ^ ^ &lt; &lt; &lt; . . . . 
^ ######^ . . . . . 
^ ######. . . . . . 
^ . . . . . . . . . 

5  4  5  6  7  8  9  10 11 12 
4  3  4  5  10 13 10 11 12 13 
3  2  3  4  9  14 15 12 13 14 
2  1  2  3  8  13 .  17 14 15 
1  0  1  6  11 16 .  20 15 16 
2  1  2  7  12 17 .  .  16 .  
3  2  3  4  9  14 .  .  .  .  
4  #########14 .  .  .  .  .  
5  #########.  .  .  .  .  .  
6  .  .  .  .  .  .  .  .  .  

.  .  .  @  @  @  @  .  .  .  
.  .  .  @  .  .  @  @  .  .  
.  .  .  @  .  .  .  @  @  .  
.  .  @  @  .  .  .  .  @  .  
.  @  @  .  .  .  .  .  @  .  
.  .  .  .  .  .  .  .  @  .  
.  .  .  .  .  .  .  .  .  .  
.  #########.  .  .  .  .  .  
.  #########.  .  .  .  .  .  
.  .  .  .  .  .  .  .  .  .
</pre></div><h4 id="orgb997996"><span class="section-number-4">2.4.1</span> Straighter paths</h4><p>If you implement this code in your own project you might find that some of the paths aren’t as “straight” as you’d like. <b>This is normal</b>. When using <i>grids</i>, especially grids where every step has the same movement cost, you end up with <b>ties</b>: many paths have exactly the same cost. A* ends up picking one of the many short paths, and very often <b>it doesn’t look good to you</b>. The quick hack is to <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties">break the ties</a><sup class="print-endnote">[4]</sup>, but it’s not entirely satisfactory. The better approach is to <a href="https://www.redblobgames.com/pathfinding/grids/algorithms.html">change the map representation</a>, which makes A* a lot faster, and also produces straighter, better looking paths. However, that only works for mostly-static maps where every step has the same movement cost. For the demos on my page, I’m using a quick hack, but it only works with my slow priority queue. If you switch to a faster priority queue you’ll need a different quick hack.</p><h3 id="orge610868"><span class="section-number">&nbsp;2.5&nbsp;</span><span>Production code</span></h3><p>The C++ code I’ve shown above is simplified to make it easier to follow the algorithm and data structures. In practice there are many things you’d want to do differently:</p><ul class="org-ul"><li>inlining small functions</li><li>the <code>Location</code> parameter should be part of the <code>Graph</code></li><li>the cost could be int or double, and should be part of the <code>Graph</code></li><li>use <code>array</code> instead of <code>unordered_set</code> if the ids are dense integers, and reset these values on exit instead of initializing on entry</li><li>pass larger data structures by reference instead of by value</li><li>return larger data structures in out parameters instead of returning them, or use move constructors (for example, the vector returned from the <code>neighbors</code> function)</li><li>the heuristic can vary and should be a template parameter to the A* function so that it can be inlined</li></ul><p>Here’s how the A* code might look different with some (but not all) of these changes:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">a_star_search</span>
  <span class="paren">(</span><span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">function</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::cost_t<span class="paren">(</span><span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">a</span>, <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">b</span><span class="paren">)</span>&gt; <span class="variable-name">heuristic</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>, <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>, <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">cost_t</span>&gt;&amp; <span class="variable-name">cost_so_far</span><span class="paren">)</span>
<span class="minor-control-construct"><span class="paren">{</span></span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="type">Location</span>;
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">cost_t</span> <span class="type">cost_t</span>;
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">cost_t</span>&gt; <span class="variable-name">frontier</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">neighbors</span>;
  frontier.put<span class="paren">(</span>start, cost_t<span class="paren">(</span><span class="constant">0</span><span class="paren">))</span>;

  came_from<span class="paren">[</span>start<span class="paren">]</span> = start;
  cost_so_far<span class="paren">[</span>start<span class="paren">]</span> = cost_t<span class="paren">(</span><span class="constant">0</span><span class="paren">)</span>;
  
  <span class="keyword">while</span> <span class="paren">(</span><span class="negation-char">!</span>frontier.empty<span class="paren">())</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    <span class="keyword">typename</span> <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get<span class="paren">()</span>;

    <span class="keyword">if</span> <span class="paren">(</span>current == goal<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="major-control-construct">break</span>;
    <span class="minor-control-construct"><span class="paren">}</span></span>

    graph.get_neighbors<span class="paren">(</span>current, neighbors<span class="paren">)</span>;
    <span class="keyword">for</span> <span class="paren">(</span><span class="type">Location</span> <span class="variable-name">next</span> : neighbors<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
      <span class="type">cost_t</span> <span class="variable-name">new_cost</span> = cost_so_far<span class="paren">[</span>current<span class="paren">]</span> + graph.cost<span class="paren">(</span>current, next<span class="paren">)</span>;
      <span class="keyword">if</span> <span class="paren">(</span>cost_so_far.find<span class="paren">(</span>next<span class="paren">)</span> == cost_so_far.end<span class="paren">()</span>
          || new_cost &lt; cost_so_far<span class="paren">[</span>next<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        cost_so_far<span class="paren">[</span>next<span class="paren">]</span> = new_cost;
        <span class="type">cost_t</span> <span class="variable-name">priority</span> = new_cost + heuristic<span class="paren">(</span>next, goal<span class="paren">)</span>;
        frontier.put<span class="paren">(</span>next, priority<span class="paren">)</span>;
        came_from<span class="paren">[</span>next<span class="paren">]</span> = current;
      <span class="minor-control-construct"><span class="paren">}</span></span>
    <span class="minor-control-construct"><span class="paren">}</span></span>
  <span class="minor-control-construct"><span class="paren">}</span></span>
<span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><p>I wanted the code on this page to be about the algorithms and data structures and not about the C++ optimizations so I tried to show simple code instead of fast or abstract code.</p></section><section><h2 id="csharp"><span class="section-number">&nbsp;3&nbsp; </span><span>C# Implementation</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#csharp">#</a></h2><p>These were my first C# programs so they might not be idiomatic or stylistically proper. These examples aren’t as complete as the Python and C++ sections, but I hope they’re helpful.</p><p>Here’s a simple graph, and Breadth First Search:</p><div class="org-src-container"><pre class="src src-csharp"><span class="keyword">using</span> <span class="constant">System</span>;
<span class="keyword">using</span> <span class="constant">System.Collections.Generic</span>;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">Graph</span>&lt;Location&gt;
<span class="paren">{</span>
    <span class="comment-delimiter">// </span><span class="comment">NameValueCollection would be a reasonable alternative here, if</span>
    <span class="comment-delimiter">// </span><span class="comment">you're always using string location types</span>
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;Location, Location<span class="paren">[]</span>&gt; <span class="variable-name">edges</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;Location, Location<span class="paren">[]</span>&gt;<span class="paren">()</span>;

    <span class="keyword">public</span> <span class="type">Location</span><span class="paren">[]</span> <span class="function-name">Neighbors</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">id</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">return</span> edges<span class="paren">[</span>id<span class="paren">]</span>;
    <span class="paren">}</span>
<span class="paren">}</span>;


<span class="keyword">class</span> <span class="type">BreadthFirstSearch</span>
<span class="paren">{</span>
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Search</span><span class="paren">(</span><span class="type">Graph</span>&lt;<span class="type">string</span>&gt; <span class="variable-name">graph</span>, <span class="type">string</span> <span class="variable-name">start</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">var</span> <span class="variable-name">frontier</span> = <span class="keyword">new</span> <span class="type">Queue</span>&lt;<span class="type">string</span>&gt;<span class="paren">()</span>;
        frontier.<span class="function-name">Enqueue</span><span class="paren">(</span><span class="type">start</span><span class="paren">)</span>;

        <span class="keyword">var</span> <span class="variable-name">visited</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">string</span>&gt;<span class="paren">()</span>;
        visited.<span class="function-name">Add</span><span class="paren">(</span><span class="type">start</span><span class="paren">)</span>;

        <span class="keyword">while</span> <span class="paren">(</span>frontier.Count &gt; <span class="constant">0</span><span class="paren">)</span>
        <span class="paren">{</span>
            <span class="keyword">var</span> <span class="variable-name">current</span> = frontier.<span class="function-name">Dequeue</span><span class="paren">()</span>;

            Console.<span class="function-name">WriteLine</span><span class="paren">(</span><span class="string">"Visiting </span><span class="string"><span class="paren">{</span></span><span class="string">0</span><span class="string"><span class="paren">}</span></span><span class="string">"</span>, <span class="type">current</span><span class="paren">)</span>;
            <span class="keyword">foreach</span> <span class="paren">(</span><span class="keyword">var</span> <span class="function-name">next</span> <span class="keyword">in</span> graph.<span class="function-name">Neighbors</span><span class="paren">(</span><span class="type">current</span><span class="paren">))</span>
            <span class="paren">{</span>
                <span class="keyword">if</span> <span class="paren">(</span>!visited.<span class="function-name">Contains</span><span class="paren">(</span><span class="type">next</span><span class="paren">))</span> <span class="paren">{</span>
                    frontier.<span class="function-name">Enqueue</span><span class="paren">(</span><span class="type">next</span><span class="paren">)</span>;
                    visited.<span class="function-name">Add</span><span class="paren">(</span><span class="type">next</span><span class="paren">)</span>;
                <span class="paren">}</span>
            <span class="paren">}</span>
        <span class="paren">}</span>
    <span class="paren">}</span>
    
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Main</span><span class="paren">()</span>
    <span class="paren">{</span>
        <span class="type">Graph</span>&lt;<span class="type">string</span>&gt; <span class="variable-name">g</span> = <span class="keyword">new</span> <span class="type">Graph</span>&lt;<span class="type">string</span>&gt;<span class="paren">()</span>;
        g.edges = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">string</span>, <span class="type">string</span><span class="paren">[]</span>&gt;
            <span class="paren">{</span>
            <span class="paren">{</span> <span class="string">"A"</span>, <span class="keyword">new</span> <span class="paren">[]</span> <span class="paren">{</span> <span class="string">"B"</span> <span class="paren">}</span> <span class="paren">}</span>,
            <span class="paren">{</span> <span class="string">"B"</span>, <span class="keyword">new</span> <span class="paren">[]</span> <span class="paren">{</span> <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"D"</span> <span class="paren">}</span> <span class="paren">}</span>,
            <span class="paren">{</span> <span class="string">"C"</span>, <span class="keyword">new</span> <span class="paren">[]</span> <span class="paren">{</span> <span class="string">"A"</span> <span class="paren">}</span> <span class="paren">}</span>,
            <span class="paren">{</span> <span class="string">"D"</span>, <span class="keyword">new</span> <span class="paren">[]</span> <span class="paren">{</span> <span class="string">"E"</span>, <span class="string">"A"</span> <span class="paren">}</span> <span class="paren">}</span>,
            <span class="paren">{</span> <span class="string">"E"</span>, <span class="keyword">new</span> <span class="paren">[]</span> <span class="paren">{</span> <span class="string">"B"</span> <span class="paren">}</span> <span class="paren">}</span>
        <span class="paren">}</span>;

        Search<span class="paren">(</span><span class="type">g</span>, <span class="string">"A"</span><span class="paren">)</span>;
    <span class="paren">}</span>
<span class="paren">}</span>
</pre></div><p>Here’s a graph representing a grid with weighted edges (the forest and walls example from the main page):</p><div class="org-src-container"><pre class="src src-csharp"><span class="keyword">using</span> <span class="constant">System</span>;
<span class="keyword">using</span> <span class="constant">System.Collections.Generic</span>;


<span class="comment-delimiter">// </span><span class="comment">A* needs only a WeightedGraph and a location type L, and does *not*</span>
<span class="comment-delimiter">// </span><span class="comment">have to be a grid. However, in the example code I am using a grid.</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="type">WeightedGraph</span>&lt;L&gt;
<span class="paren">{</span>
    <span class="type">double</span> <span class="function-name">Cost</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span><span class="paren">)</span>;
    <span class="type">IEnumerable</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">Neighbors</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">id</span><span class="paren">)</span>;
<span class="paren">}</span>


<span class="keyword">public</span> <span class="keyword">struct</span> <span class="type">Location</span>
<span class="paren">{</span>
    <span class="comment-delimiter">// </span><span class="comment">Implementation notes: I am using the default Equals but it can</span>
    <span class="comment-delimiter">// </span><span class="comment">be slow. You'll probably want to override both Equals and</span>
    <span class="comment-delimiter">// </span><span class="comment">GetHashCode in a real project.</span>
    
    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="type">int</span> x, <span class="variable-name">y</span>;
    <span class="keyword">public</span> Location<span class="paren">(</span><span class="type">int</span> <span class="variable-name">x</span>, <span class="type">int</span> <span class="variable-name">y</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
    <span class="paren">}</span>
<span class="paren">}</span>


<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">SquareGrid</span> : <span class="type">WeightedGraph</span>&lt;<span class="type">Location</span>&gt;
<span class="paren">{</span>
    <span class="comment-delimiter">// </span><span class="comment">Implementation notes: I made the fields public for convenience,</span>
    <span class="comment-delimiter">// </span><span class="comment">but in a real project you'll probably want to follow standard</span>
    <span class="comment-delimiter">// </span><span class="comment">style and make them private.</span>
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="variable-name">Location</span><span class="paren">[]</span> DIRS = <span class="keyword">new</span> <span class="paren">[]</span>
        <span class="paren">{</span>
            <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">1</span>, <span class="constant">0</span><span class="paren">)</span>,
            <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">0</span>, -<span class="constant">1</span><span class="paren">)</span>,
            <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span>-<span class="constant">1</span>, <span class="constant">0</span><span class="paren">)</span>,
            <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">0</span>, <span class="constant">1</span><span class="paren">)</span>
        <span class="paren">}</span>;

    <span class="keyword">public</span> <span class="type">int</span> <span class="variable-name">width</span>, <span class="variable-name">height</span>;
    <span class="keyword">public</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">walls</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;<span class="paren">()</span>;
    <span class="keyword">public</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">forests</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;<span class="paren">()</span>;

    <span class="keyword">public</span> SquareGrid<span class="paren">(</span><span class="type">int</span> <span class="variable-name">width</span>, <span class="type">int</span> <span class="variable-name">height</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
    <span class="paren">}</span>

    <span class="keyword">public</span> <span class="type">bool</span> <span class="function-name">InBounds</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">id</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">return</span> <span class="constant">0</span> &lt;= id.x &amp;&amp; id.x &lt; width
            &amp;&amp; <span class="constant">0</span> &lt;= id.y &amp;&amp; id.y &lt; height;
    <span class="paren">}</span>

    <span class="keyword">public</span> <span class="type">bool</span> <span class="function-name">Passable</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">id</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">return</span> !walls.<span class="function-name">Contains</span><span class="paren">(</span>id<span class="paren">)</span>;
    <span class="paren">}</span>

    <span class="keyword">public</span> <span class="type">double</span> <span class="function-name">Cost</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">return</span> forests.<span class="function-name">Contains</span><span class="paren">(</span>b<span class="paren">)</span> ? <span class="constant">5</span> : <span class="constant">1</span>;
    <span class="paren">}</span>
    
    <span class="keyword">public</span> <span class="type">IEnumerable</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">Neighbors</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">id</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">foreach</span> <span class="paren">(</span><span class="keyword">var</span> <span class="variable-name">dir</span> <span class="keyword">in</span> DIRS<span class="paren">)</span> <span class="paren">{</span>
            <span class="type">Location</span> <span class="variable-name">next</span> = <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span>id.x + dir.x, id.y + dir.y<span class="paren">)</span>;
            <span class="keyword">if</span> <span class="paren">(</span>InBounds<span class="paren">(</span>next<span class="paren">)</span> &amp;&amp; Passable<span class="paren">(</span>next<span class="paren">))</span> <span class="paren">{</span>
                <span class="keyword">yield</span> <span class="keyword">return</span> next;
            <span class="paren">}</span>
        <span class="paren">}</span>
    <span class="paren">}</span>
<span class="paren">}</span>


<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">PriorityQueue</span>&lt;T&gt;
<span class="paren">{</span>
    <span class="comment-delimiter">// </span><span class="comment">I'm using an unsorted array for this example, but ideally this</span>
    <span class="comment-delimiter">// </span><span class="comment">would be a binary heap. There's an open issue for adding a binary</span>
    <span class="comment-delimiter">// </span><span class="comment">heap to the standard C# library: https://github.com/dotnet/corefx/issues/574</span>
    <span class="comment-delimiter">//</span>
    <span class="comment-delimiter">// </span><span class="comment">Until then, find a binary heap class:</span>
    <span class="comment-delimiter">// </span><span class="comment">* https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp</span>
    <span class="comment-delimiter">// </span><span class="comment">* http://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx</span>
    <span class="comment-delimiter">// </span><span class="comment">* http://xfleury.github.io/graphsearch.html</span>
    <span class="comment-delimiter">// </span><span class="comment">* http://stackoverflow.com/questions/102398/priority-queue-in-net</span>
    
    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Tuple</span>&lt;T, <span class="type">double</span>&gt;&gt; <span class="variable-name">elements</span> = <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">Tuple</span>&lt;T, <span class="type">double</span>&gt;&gt;<span class="paren">()</span>;

    <span class="keyword">public</span> <span class="type">int</span> <span class="variable-name">Count</span>
    <span class="paren">{</span>
        <span class="keyword">get</span> <span class="paren">{</span> <span class="keyword">return</span> elements.Count; <span class="paren">}</span>
    <span class="paren">}</span>
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">Enqueue</span><span class="paren">(</span><span class="type">T</span> <span class="variable-name">item</span>, <span class="type">double</span> <span class="variable-name">priority</span><span class="paren">)</span>
    <span class="paren">{</span>
        elements.<span class="function-name">Add</span><span class="paren">(</span>Tuple.<span class="function-name">Create</span><span class="paren">(</span><span class="type">item</span>, <span class="type">priority</span><span class="paren">))</span>;
    <span class="paren">}</span>

    <span class="keyword">public</span> <span class="type">T</span> <span class="function-name">Dequeue</span><span class="paren">()</span>
    <span class="paren">{</span>
        <span class="type">int</span> <span class="variable-name">bestIndex</span> = <span class="constant">0</span>;

        <span class="keyword">for</span> <span class="paren">(</span><span class="type">int</span> <span class="variable-name">i</span> = <span class="constant">0</span>; i &lt; elements.Count; i++<span class="paren">)</span> <span class="paren">{</span>
            <span class="keyword">if</span> <span class="paren">(</span>elements<span class="paren">[</span>i<span class="paren">]</span>.Item2 &lt; elements<span class="paren">[</span>bestIndex<span class="paren">]</span>.Item2<span class="paren">)</span> <span class="paren">{</span>
                bestIndex = i;
            <span class="paren">}</span>
        <span class="paren">}</span>

        <span class="type">T</span> <span class="variable-name">bestItem</span> = elements<span class="paren">[</span>bestIndex<span class="paren">]</span>.Item1;
        elements.<span class="function-name">RemoveAt</span><span class="paren">(</span><span class="type">bestIndex</span><span class="paren">)</span>;
        <span class="keyword">return</span> bestItem;
    <span class="paren">}</span>
<span class="paren">}</span>


<span class="comment-delimiter">/* </span><span class="comment">NOTE about types: in the main article, in the Python code I just</span>
<span class="comment"> * use numbers for costs, heuristics, and priorities. In the C++ code</span>
<span class="comment"> * I use a typedef for this, because you might want int or double or</span>
<span class="comment"> * another type. In this C# code I use double for costs, heuristics,</span>
<span class="comment"> * and priorities. You can use an int if you know your values are</span>
<span class="comment"> * always integers, and you can use a smaller size number if you know</span>
<span class="comment"> * the values are always small. */</span>

<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">AStarSearch</span>
<span class="paren">{</span>
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">cameFrom</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;<span class="paren">()</span>;
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">costSoFar</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;<span class="paren">()</span>;

    <span class="comment-delimiter">// </span><span class="comment">Note: a generic version of A* would abstract over Location and</span>
    <span class="comment-delimiter">// </span><span class="comment">also Heuristic</span>
    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">double</span> <span class="function-name">Heuristic</span><span class="paren">(</span><span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">return</span> Math.<span class="function-name">Abs</span><span class="paren">(</span>a.x - b.x<span class="paren">)</span> + Math.<span class="function-name">Abs</span><span class="paren">(</span>a.y - b.y<span class="paren">)</span>;
    <span class="paren">}</span>

    <span class="keyword">public</span> AStarSearch<span class="paren">(</span><span class="type">WeightedGraph</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span><span class="paren">)</span>
    <span class="paren">{</span>
        <span class="keyword">var</span> <span class="variable-name">frontier</span> = <span class="keyword">new</span> <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>&gt;<span class="paren">()</span>;
        frontier.<span class="function-name">Enqueue</span><span class="paren">(</span><span class="type">start</span>, <span class="constant">0</span><span class="paren">)</span>;

        cameFrom<span class="paren">[</span>start<span class="paren">]</span> = start;
        costSoFar<span class="paren">[</span>start<span class="paren">]</span> = <span class="constant">0</span>;

        <span class="keyword">while</span> <span class="paren">(</span>frontier.Count &gt; <span class="constant">0</span><span class="paren">)</span>
        <span class="paren">{</span>
            <span class="keyword">var</span> <span class="variable-name">current</span> = frontier.<span class="function-name">Dequeue</span><span class="paren">()</span>;

            <span class="keyword">if</span> <span class="paren">(</span>current.<span class="function-name">Equals</span><span class="paren">(</span><span class="type">goal</span><span class="paren">))</span>
            <span class="paren">{</span>
                <span class="keyword">break</span>;
            <span class="paren">}</span>

            <span class="keyword">foreach</span> <span class="paren">(</span><span class="keyword">var</span> <span class="function-name">next</span> <span class="keyword">in</span> graph.<span class="function-name">Neighbors</span><span class="paren">(</span><span class="type">current</span><span class="paren">))</span>
            <span class="paren">{</span>
                <span class="type">double</span> <span class="variable-name">newCost</span> = costSoFar<span class="paren">[</span>current<span class="paren">]</span>
                    + graph.<span class="function-name">Cost</span><span class="paren">(</span><span class="type">current</span>, <span class="type">next</span><span class="paren">)</span>;
                <span class="keyword">if</span> <span class="paren">(</span>!costSoFar.<span class="function-name">ContainsKey</span><span class="paren">(</span><span class="type">next</span><span class="paren">)</span>
                    || newCost &lt; costSoFar<span class="paren">[</span>next<span class="paren">])</span>
                <span class="paren">{</span>
                    costSoFar<span class="paren">[</span>next<span class="paren">]</span> = newCost;
                    <span class="type">double</span> <span class="variable-name">priority</span> = newCost + Heuristic<span class="paren">(</span><span class="type">next</span>, <span class="type">goal</span><span class="paren">)</span>;
                    frontier.<span class="function-name">Enqueue</span><span class="paren">(</span><span class="type">next</span>, <span class="type">priority</span><span class="paren">)</span>;
                    cameFrom<span class="paren">[</span>next<span class="paren">]</span> = current;
                <span class="paren">}</span>
            <span class="paren">}</span>
        <span class="paren">}</span>
    <span class="paren">}</span>
<span class="paren">}</span>

<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">Test</span>
<span class="paren">{</span>
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">DrawGrid</span><span class="paren">(</span><span class="type">SquareGrid</span> <span class="variable-name">grid</span>, <span class="type">AStarSearch</span> <span class="variable-name">astar</span><span class="paren">)</span> <span class="paren">{</span>
        <span class="comment-delimiter">// </span><span class="comment">Print out the cameFrom array</span>
        <span class="keyword">for</span> <span class="paren">(</span><span class="keyword">var</span> <span class="variable-name">y</span> = <span class="constant">0</span>; y &lt; <span class="constant">10</span>; y++<span class="paren">)</span>
        <span class="paren">{</span>
            <span class="keyword">for</span> <span class="paren">(</span><span class="keyword">var</span> <span class="variable-name">x</span> = <span class="constant">0</span>; x &lt; <span class="constant">10</span>; x++<span class="paren">)</span>
            <span class="paren">{</span>
                <span class="type">Location</span> <span class="variable-name">id</span> = <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="type">x</span>, <span class="type">y</span><span class="paren">)</span>;
                <span class="type">Location</span> <span class="variable-name">ptr</span> = id;
                <span class="keyword">if</span> <span class="paren">(</span>!astar.cameFrom.<span class="function-name">TryGetValue</span><span class="paren">(</span><span class="type">id</span>, <span class="keyword">out</span> <span class="type">ptr</span><span class="paren">))</span>
                <span class="paren">{</span>
                    ptr = id;
                <span class="paren">}</span>
                <span class="keyword">if</span> <span class="paren">(</span>grid.walls.<span class="function-name">Contains</span><span class="paren">(</span><span class="type">id</span><span class="paren">))</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"##"</span><span class="paren">)</span>; <span class="paren">}</span>
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="paren">(</span>ptr.x == x+<span class="constant">1</span><span class="paren">)</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"\u2192 "</span><span class="paren">)</span>; <span class="paren">}</span>
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="paren">(</span>ptr.x == x-<span class="constant">1</span><span class="paren">)</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"\u2190 "</span><span class="paren">)</span>; <span class="paren">}</span>
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="paren">(</span>ptr.y == y+<span class="constant">1</span><span class="paren">)</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"\u2193 "</span><span class="paren">)</span>; <span class="paren">}</span>
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="paren">(</span>ptr.y == y-<span class="constant">1</span><span class="paren">)</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"\u2191 "</span><span class="paren">)</span>; <span class="paren">}</span>
                <span class="keyword">else</span> <span class="paren">{</span> Console.<span class="function-name">Write</span><span class="paren">(</span><span class="string">"* "</span><span class="paren">)</span>; <span class="paren">}</span>
            <span class="paren">}</span>
            Console.<span class="function-name">WriteLine</span><span class="paren">()</span>;
        <span class="paren">}</span>
    <span class="paren">}</span>
    
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Main</span><span class="paren">()</span>
    <span class="paren">{</span>
        <span class="comment-delimiter">// </span><span class="comment">Make "diagram 4" from main article</span>
        <span class="keyword">var</span> <span class="variable-name">grid</span> = <span class="keyword">new</span> <span class="type">SquareGrid</span><span class="paren">(</span><span class="constant">10</span>, <span class="constant">10</span><span class="paren">)</span>;
        <span class="keyword">for</span> <span class="paren">(</span><span class="keyword">var</span> <span class="variable-name">x</span> = <span class="constant">1</span>; x &lt; <span class="constant">4</span>; x++<span class="paren">)</span>
        <span class="paren">{</span>
            <span class="keyword">for</span> <span class="paren">(</span><span class="keyword">var</span> <span class="variable-name">y</span> = <span class="constant">7</span>; y &lt; <span class="constant">9</span>; y++<span class="paren">)</span>
            <span class="paren">{</span>
                grid.walls.<span class="function-name">Add</span><span class="paren">(</span><span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="type">x</span>, <span class="type">y</span><span class="paren">))</span>;
            <span class="paren">}</span>
        <span class="paren">}</span>
        grid.forests = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;
            <span class="paren">{</span>
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">3</span>, <span class="constant">4</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">3</span>, <span class="constant">5</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">1</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">2</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">3</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">4</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">5</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">6</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">7</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">4</span>, <span class="constant">8</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">1</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">2</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">3</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">4</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">5</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">6</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">7</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">5</span>, <span class="constant">8</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">2</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">3</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">4</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">5</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">6</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">6</span>, <span class="constant">7</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">7</span>, <span class="constant">3</span><span class="paren">)</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">7</span>, <span class="constant">4</span><span class="paren">)</span>,
                <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">7</span>, <span class="constant">5</span><span class="paren">)</span>
            <span class="paren">}</span>;

        <span class="comment-delimiter">// </span><span class="comment">Run A*</span>
        <span class="keyword">var</span> <span class="variable-name">astar</span> = <span class="keyword">new</span> <span class="type">AStarSearch</span><span class="paren">(</span><span class="type">grid</span>, <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">1</span>, <span class="constant">4</span><span class="paren">)</span>,
                                    <span class="keyword">new</span> <span class="type">Location</span><span class="paren">(</span><span class="constant">8</span>, <span class="constant">5</span><span class="paren">))</span>;

        DrawGrid<span class="paren">(</span><span class="type">grid</span>, <span class="type">astar</span><span class="paren">)</span>;
    <span class="paren">}</span>
<span class="paren">}</span>
</pre></div></section><section><h2 id="algorithm"><span class="section-number">&nbsp;4&nbsp; </span><span>Algorithm changes</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm">#</a></h2><p>The version of Dijkstra’s Algorithm and A* on my pages is slightly different from what you’ll see in an algorithms or AI textbook.</p><p>The pure version of Dijkstra’s Algorithm starts the priority queue with all nodes, and does not have early exit. It uses a “decrease-key” operation in the queue. It’s fine in theory. But in practice…</p><ol class="org-ol"><li>By starting the priority with only the start node, we can keep it small, which makes it faster and use less memory.</li><li>With early exit, we almost never need to insert all the nodes into the queue, and we can return the path as soon as it’s found.</li><li>By not putting all nodes into the queue at the start, most of the time we can use a cheap insert operation instead of the more expensive decrease-key operation.</li><li>By not putting all nodes into the queue at the start, we can handle situations where we do not even know all the nodes, or where the number of nodes is infinite.</li></ol><p>This variant is sometimes called “Uniform Cost Search”. See <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Practical_optimizations_and_infinite_graphs">Wikipedia</a><sup class="print-endnote">[5]</sup> to see the pseudocode, or read <a href="https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4017/4357">this paper</a><sup class="print-endnote">[6]</sup> [PDF] to see justifications for these changes.</p><p>There are three further differences between my version and what you might find elsewhere. These apply to both Dijkstra’s Algorithm and A*:</p><ol class="org-ol"><li value="5">I eliminate the check for a node being in the frontier with a higher cost. By not checking, I end up with duplicate elements in the frontier. <i>The algorithm still works.</i> It will revisit some locations more than necessary (but rarely, in my experience). The code is simpler and it allows me to use a simpler and faster priority queue that does not support the decrease-key operation. The paper <a href="http://www.cs.sunysb.edu/~rezaul/papers/TR-07-54.pdf">“Priority Queues and Dijkstra’s Algorithm”</a><sup class="print-endnote">[7]</sup> suggests that this approach is faster in practice.</li><li>Instead of storing both a “closed set” and an “open set”, I have a <code>visited</code> flag that tells me whether it’s in <i>either</i> of those sets. This simplifies the code further.</li><li>I don’t need to store a separate open or closed set explicitly because the set is <i>implicit</i> in the keys of the <code>came_from</code> and <code>cost_so_far</code> tables. Since we always want one of those two tables, there’s no need to store the open/closed sets separately.</li><li>I use hash tables instead of arrays of node objects. This eliminates the rather expensive <i>initialize</i> step that many other implementations have. For large game maps, the initialization of those arrays is often slower than the rest of A*.</li></ol><p>If you have more suggestions for simplifications that preserve performance, please let me know!</p></section><section><h2 id="optimizations"><span class="section-number">&nbsp;5&nbsp; </span><span>Optimizations</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimizations">#</a></h2><div class="outline-text-2" id="text-optimizations"><p>For the code I present here, I’ve been focusing on simplicity and generality rather than performance. <b>First make it work, then make it fast.</b> Many of the optimizations I use in real projects are specific to the project, so instead of presenting optimal code, here are some ideas to pursue for your own project:</p></div><h3 id="optimize-graph"><span class="section-number">&nbsp;5.1&nbsp;</span><span>Graph</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-graph">#</a></h3><p>The biggest optimization you can make is to explore fewer nodes. My #1 recommendation is that if you’re using a grid map, <a href="https://www.redblobgames.com/pathfinding/grids/algorithms.html">consider using a non-grid</a> pathfinding graph. It’s not always feasible but it’s worth looking at.</p><p>If your graph has a simple structure (e.g. a grid), calculate the neighbors in a function. If it’s a more complex structure (either a non-grid, or a grid with lots of walls, like a maze), store the neighbors in a data structure.</p><p>You can also save a bit of copying by reusing the neighbors array. Instead of <i>returning</i> a new one each time, allocate it once in the search code and pass it into the graph’s neighbors method.</p><h3 id="optimize-queue"><span class="section-number">&nbsp;5.2&nbsp;</span><span>Queue</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-queue">#</a></h3><p>Breadth First Search uses a simple queue instead of the priority queue needed by the other algorithms. Queues are simpler and faster than priority queues. In exchange, the other algorithms usually explore fewer nodes. In most game maps, exploring fewer nodes is worth the slowdown from the other algorithms. There are some maps though where you don’t save much, and it might be better to use Breadth First Search.</p><p>For queues, use a deque instead of an array. A deque allows fast insertion and removal on either end, whereas an array is fast only at one end. In Python, see <a href="https://docs.python.org/3/library/collections.html">collections.deque</a><sup class="print-endnote">[8]</sup>; in C++, see the <a href="http://en.cppreference.com/w/cpp/container/deque">deque</a><sup class="print-endnote">[9]</sup> container. However, breadth first search doesn’t even need a queue; it can use two vectors, swapping them when one is empty.</p><p>For priority queues, use a binary heap instead of an array or sorted array. A binary heap allows fast insertion and removal, whereas an array is fast at one or the other but not both. In Python, see <a href="https://docs.python.org/2/library/heapq.html">heapq</a><sup class="print-endnote">[10]</sup>; in C++, see the <a href="http://en.cppreference.com/w/cpp/container/priority_queue">priority_queue</a><sup class="print-endnote">[11]</sup> container.</p><p>In Python, the Queue and PriorityQueue classes I presented above are so simple that you might consider inlining the methods into the search algorithm. I don’t know if this buys you much; I need to measure it. The C++ versions are going to be inlined.</p><p>In Dijkstra’s Algorithm, note that the priority queue’s priority is stored twice, once in the priority queue and once in <code>cost_so_far</code>, so you could write a priority queue that gets priorities from elsewhere. I’m not sure if it’s worth it.</p><p>The paper <a href="http://www.cs.sunysb.edu/~rezaul/papers/TR-07-54.pdf">“Priority Queues and Dijkstra’s Algorithm”</a><sup class="print-endnote">[12]</sup> by Chen, Chowdhury, Ramachandran, Lan Roche, Tong suggests optimizing the structure of Dijkstra’s Algorithm by not reprioritizing, and it also suggests looking at <a href="http://en.wikipedia.org/wiki/Pairing_heap">pairing heaps</a><sup class="print-endnote">[13]</sup> and other data structures.</p><p>If you’re considering using something other than a binary heap, first measure the size of your frontier and how often you reprioritize. Profile the code and see if the priority queue is the bottleneck.</p><p>My gut feeling is that <i>bucketing</i> is promising. Just as bucket sort and radix sort can be useful alternatives to quicksort when the keys are integers, we have an even better situation with Dijkstra’s Algorithm and A*. The priorities in Dijkstra’s Algorithm are <i>incredibly narrow</i>. If the lowest element in the queue has priority <code>f</code>, then the highest element has priority <code>f+e</code> where <code>e</code> is the maximum edge weight. In the forest example, I have edge weights 1 and 5. That means all the priorities in the queue are going to be between <code>f</code> and <code>f+5</code>. Since they’re all integers, <i>there are only six different priorities</i>. We could use six buckets and not sort anything at all! A* produces a wider range of priorities but it’s still worth looking at. And there are fancier bucketing approaches that handle a wider range of situations.</p><p>Note that if all the edge weights are 1, the priorities will all be between <code>f</code> and <code>f+1</code>. This yields a variant of Breadth First Search that uses two arrays instead of a queue, which I used <a href="https://www.redblobgames.com/grids/hexagons/#range-obstacles">on my hex grid page</a><sup class="print-endnote">[14]</sup>. If the weights are 1 or 2, you’ll have three arrays; if the weights are 1, 2, or 3, you’ll have four arrays; and so on.</p><p><a href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#set-representation">I have more note about priority queue data structures here</a><sup class="print-endnote">[15]</sup>.</p><h3 id="optimize-search"><span class="section-number">&nbsp;5.3&nbsp;</span><span>Search</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-search">#</a></h3><p>The heuristic adds complexity and cpu time. The goal though is to explore fewer nodes. In some maps (such as mazes), the heuristic may not add much information, and it may be better to use a simpler algorithm without a heuristic guide.</p><p>Some people use an <i>inadmissible</i> (overestimating) heuristic to speed up A* search. This seems reasonable. I haven’t looked closely into its implications though. I believe (but don’t know for sure) that some already-visited elements may need to be visited again even after they’ve been taken out of the frontier.</p><p>Some implementations <i>always</i> insert a new node into the open set, even if it’s already there. You can avoid the potentially expensive step of checking whether the node is already in the open set. This will make your open set bigger/slower and you’ll also end up evaluating more nodes than necessary. If the open-set test is expensive, it might still be worth it. However, in the code I’ve presented, I made the test cheap and I don’t use this approach.</p><p>Some implementations <i>don’t test</i> whether a new node is better than an existing node in the open set. This avoids a potentially expensive check. However, it also <i>can lead to a bug</i>. For some types of maps, you will not find the shortest path when you skip this test. In the code I’ve presented, I check this (<code>new_cost &lt; cost_so_far</code>). The test is cheap because I made it cheap to look up <code>cost_so_far</code>.</p><h3 id="optimize-integer-ids"><span class="section-number">&nbsp;5.4&nbsp;</span><span>Integer locations</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#optimize-integer-ids">#</a></h3><p>If your graph uses integers as locations, consider using a simple array instead of a hash table for <code>cost_so_far</code>, <code>visited</code>, <code>came_from</code>, etc. Since <code>visited</code> is an array of booleans, you can use a bit vector. Initialize the <code>visited</code> bit vector for all ids, but leave <code>cost_so_far</code> and <code>came_from</code> uninitialized. Then only initialize on the first visit.</p><div class="org-src-container"><pre class="src src-cpp"><span class="type">vector</span>&lt;<span class="type">uint16_t</span>&gt; <span class="variable-name">visited</span><span class="paren">(</span><span class="constant">1</span> + maximum_node_id/<span class="constant">16</span><span class="paren">)</span>;

…
    size_t index = node_id/<span class="constant">16</span>;
    <span class="type">uint16_t</span> <span class="variable-name">bitmask</span> = 1u &lt;&lt; <span class="paren">(</span>node_id &amp; 0xf<span class="paren">)</span>;
    <span class="keyword">if</span> <span class="paren">(</span><span class="negation-char">!</span><span class="paren">(</span>visited<span class="paren">[</span>index<span class="paren">]</span> &amp; bitmask<span class="paren">)</span>
        || new_cost &lt; cost_so_far<span class="paren">[</span>next<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        visited<span class="paren">[</span>index<span class="paren">]</span> |= bitmask;
        …
    <span class="minor-control-construct"><span class="paren">}</span></span>
</pre></div><p>If you run only one search at a time, you can statically allocate and then reuse these arrays from one invocation to the next. Then keep an array of all indices that have been assigned to the bit vector, and then reset those on exit. For example:</p><div class="org-src-container"><pre class="src src-cpp"><span class="keyword">static</span> <span class="type">vector</span>&lt;<span class="type">uint16_t</span>&gt; <span class="variable-name">visited</span><span class="paren">(</span><span class="constant">1</span> + maximum_node_id/<span class="constant">16</span><span class="paren">)</span>;
<span class="keyword">static</span> <span class="type">vector</span>&lt;<span class="type">size_t</span>&gt; <span class="variable-name">indices_to_clear</span>;
…
    size_t index = node_id/<span class="constant">16</span>;
    <span class="type">uint16_t</span> <span class="variable-name">bitmask</span> = 1u &lt;&lt; <span class="paren">(</span>node_id &amp; 0xf<span class="paren">)</span>;
    <span class="keyword">if</span> <span class="paren">(</span><span class="negation-char">!</span><span class="paren">(</span>visited<span class="paren">[</span>index<span class="paren">]</span> &amp; bitmask<span class="paren">)</span>
        || new_cost &lt; cost_so_far<span class="paren">[</span>next<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
        <span class="keyword">if</span> <span class="paren">(</span><span class="negation-char">!</span>visited<span class="paren">[</span>index<span class="paren">])</span> <span class="minor-control-construct"><span class="paren">{</span></span>
            indices_to_clear.push_back<span class="paren">(</span>index<span class="paren">)</span>;
        <span class="minor-control-construct"><span class="paren">}</span></span>
        visited<span class="paren">[</span>index<span class="paren">]</span> |= bitmask;
        …
    <span class="minor-control-construct"><span class="paren">}</span></span>
…

<span class="keyword">for</span> <span class="paren">(</span><span class="type">size_t</span> <span class="variable-name">index</span> : indices_to_clear<span class="paren">)</span> <span class="minor-control-construct"><span class="paren">{</span></span>
    visited<span class="paren">[</span>index<span class="paren">]</span> = <span class="constant">0</span>;
<span class="minor-control-construct"><span class="paren">}</span></span>
indices_to_clear.clear<span class="paren">()</span>;
</pre></div><p>(Caveat: I haven’t used or tested this code)</p></section><section><h2 id="troubleshooting"><span class="section-number">&nbsp;6&nbsp; </span><span>Troubleshooting</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting">#</a></h2><div class="outline-text-2" id="text-troubleshooting"></div><h3 id="troubleshooting-wrong-path"><span class="section-number">&nbsp;6.1&nbsp;</span><span>Wrong path</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting-wrong-path">#</a></h3><p>If you’re not getting a shortest path, try testing:</p><ul class="org-ul"><li>Does your priority queue work correctly? Try stopping the search and dequeuing all the elements. They should all be in order.</li><li>Does your heuristic ever overestimate the true distance? The <code>priority</code> of a new node should never be lower than the priority of its parent, unless you are overestimating the distance (you can do this but you won’t get shortest paths anymore).</li><li>In a statically typed language, the cost, heuristic, and priority values need to have compatible types. The sample code on this page works with either integers or floating point types, but not all graphs and heuristics are limited to integer values. Since priorities are the sum of costs and heuristics, the priorities will need to be floating point if <i>either</i> costs or heuristics are floating point.</li></ul><h3 id="troubleshooting-ugly-path"><span class="section-number">&nbsp;6.2&nbsp;</span><span>Ugly path</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#troubleshooting-ugly-path">#</a></h3><p>The most common question I get when people run A* on a grid is <i>why don’t my paths look straight?</i> If you’ve told A* that all grid movements are equal, then there are lots of shortest paths of the same length, and it’s going to pick one arbitrarily. The path is <i>short</i> but it doesn’t <i>look</i> good.</p><ul class="org-ul"><li>One solution is to <i>straighten</i> the paths afterwards, using a “string pulling” algorithm.</li><li>One solution is to <i>guide</i> the paths in the right direction, by adjusting the heuristic. There are some cheap tricks that don’t work in all situations; <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties">read more here</a><sup class="print-endnote">[16]</sup>.</li><li>One solution is to <i>not use a grid</i>. Tell A* just the places where you might turn, instead of every grid square; <a href="https://www.redblobgames.com/pathfinding/grids/algorithms.html">read more here</a>.</li><li>One solution is a hack, but it works some of the time. When iterating through neighbors, instead of always using the same ordering (such as north, east, south, west), change the ordering on “odd” grid nodes (those where (x+y) % 2 == 1). <b>I use this trick on these tutorial pages.</b></li></ul></section><section><h2 id="more"><span class="section-number">&nbsp;7&nbsp; </span><span>More reading</span><a class="anchor" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#more">#</a></h2><ul class="org-ul"><li>Aleksander Nowak has written a <b>Go version</b> of this code at <a href="https://github.com/vyrwu/a-star-redblob">https://github.com/vyrwu/a-star-redblob</a><sup class="print-endnote">[17]</sup></li><li>Algorithms textbooks often use mathematical notation with single-letter variable names. In these pages I’ve tried to use more descriptive variable names. Correspondences: <ul class="org-ul"><li><code>cost</code> is sometimes written as <i>w</i> or <i>d</i> or <i>l</i> or length</li><li><code>cost_so_far</code> is usually written as <i>g</i> or <i>d</i> or distance</li><li><code>heuristic</code> is usually written as <i>h</i></li><li>In A*, the <code>priority</code> is usually written as <i>f</i>, where <i>f</i> = <i>g</i> + <i>h</i></li><li><code>came_from</code> is sometimes written as <i>π</i> or parent or previous or prev</li><li><code>frontier</code> is usually called OPEN</li><li><code>visited</code> is the union of OPEN and CLOSED</li><li>locations such as <code>current</code> and <code>next</code> are written with letters <i>u</i>, <i>v</i></li></ul></li><li>Wikipedia links: <ul class="org-ul"><li><a href="http://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a><sup class="print-endnote">[18]</sup></li><li><a href="http://en.wikipedia.org/wiki/Graph_(data_structure)">Graph</a><sup class="print-endnote">[19]</sup></li><li><a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a><sup class="print-endnote">[20]</sup></li><li>(Greedy) <a href="http://en.wikipedia.org/wiki/Best-first_search">Best-First Search</a><sup class="print-endnote">[21]</sup></li><li><a href="http://en.wikipedia.org/wiki/Dijkstra&#39;s_algorithm">Dijkstra’s Algorithm</a><sup class="print-endnote">[22]</sup></li><li><a href="http://en.wikipedia.org/wiki/A*_search_algorithm">A* Algorithm</a><sup class="print-endnote">[23]</sup></li></ul></li></ul></section></main><div class="divider"></div><div class="below-divider"><p>
            Email me at
            <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>,
                or tweet to <a rel="me" href="https://twitter.com/redblobgames">@redblobgames</a>,
              
            or post a public comment:
            </p><div class="print-endnote"><h3>Endnotes</h3><ol><li>[1]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html</li><li>[2]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties</li><li>[3]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html</li><li>[4]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties</li><li>[5]:&nbsp;
        https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Practical_optimizations_and_infinite_graphs</li><li>[6]:&nbsp;
        https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4017/4357</li><li>[7]:&nbsp;
        http://www.cs.sunysb.edu/~rezaul/papers/TR-07-54.pdf</li><li>[8]:&nbsp;
        https://docs.python.org/3/library/collections.html</li><li>[9]:&nbsp;
        http://en.cppreference.com/w/cpp/container/deque</li><li>[10]:&nbsp;
        https://docs.python.org/2/library/heapq.html</li><li>[11]:&nbsp;
        http://en.cppreference.com/w/cpp/container/priority_queue</li><li>[12]:&nbsp;
        http://www.cs.sunysb.edu/~rezaul/papers/TR-07-54.pdf</li><li>[13]:&nbsp;
        http://en.wikipedia.org/wiki/Pairing_heap</li><li>[14]:&nbsp;
        https://www.redblobgames.com/grids/hexagons/#range-obstacles</li><li>[15]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#set-representation</li><li>[16]:&nbsp;
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties</li><li>[17]:&nbsp;
        https://github.com/vyrwu/a-star-redblob</li><li>[18]:&nbsp;
        http://en.wikipedia.org/wiki/Queue_(abstract_data_type)</li><li>[19]:&nbsp;
        http://en.wikipedia.org/wiki/Graph_(data_structure)</li><li>[20]:&nbsp;
        http://en.wikipedia.org/wiki/Breadth-first_search</li><li>[21]:&nbsp;
        http://en.wikipedia.org/wiki/Best-first_search</li><li>[22]:&nbsp;
        http://en.wikipedia.org/wiki/Dijkstra’s_algorithm</li><li>[23]:&nbsp;
        http://en.wikipedia.org/wiki/A*_search_algorithm</li></ol></div><div class="comments" role="complementary"><div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div><script async="" type="text/javascript" src="./Implementation of A__files/ga.js.下载"></script><script async="" type="text/javascript" src="./Implementation of A__files/gap.min.js.下载"></script><script><!--
                function disqus_config(){this.page.url="http://www.redblobgames.com/pathfinding/a-star/implementation.html"}
                function $disqus(){;$disqus=()=>{};let s=document.createElement('script');s.async=true;s.setAttribute('data-timestamp',+new Date());s.src="//redblobgames.disqus.com/embed.js";document.body.appendChild(s)}
                if(document.location.hash.match(/#comment/))$disqus();
                else if(document.location.hostname!='localhost'&&'IntersectionObserver' in window){new IntersectionObserver(e=>{if(e[0].isIntersecting)$disqus()}).observe(document.getElementById('disqus_thread'))};
              --></script><noscript><a href="//%24.disqus.com/?url=https://www.redblobgames.com/pathfinding/a-star/implementation.html">View the discussion thread.</a></noscript></div></div><footer><div><address>
		  Copyright © 2019
                  <a rel="author home copyright" href="https://www.redblobgames.com/">Red Blob Games</a></address><div>
	      &nbsp;<p>Created 6 Jul 2014 with <a href="http://orgmode.org/">Emacs Org-mode</a>, from <a href="https://www.redblobgames.com/pathfinding/a-star/implementation.org">implementation.org</a>. Last modified: 3 Mar 2019</p></div></div><!-- Start of counters --><script><!--
var sc_project=417499,sc_invisible=1,sc_security="";
(function() {
var s=document.createElement('script');
s.async=true;s.src='//statcounter.com/counter/counter_xhtml.js';
if(document.location.hostname!='localhost')document.body.appendChild(s);
})();
                //--></script><noscript><div class="statcounter"><a class="statcounter" href="//statcounter.com/"><img class="statcounter" src="//c.statcounter.com/417499/0//1/" alt=""></a></div></noscript><script>
var _gap = _gap || [];
_gap.push(['_setAccount', 'UA-79181-1']);
_gap.push(['_setDomainName', 'redblobgames.com']);
_gap.push(['_setAllowLinker', true]);
_gap.push(['_gat._anonymizeIp']);
_gap.push(['_trackPageview']);
_gap.push(['_gapTrackBounceViaTime', 30]);
_gap.push(['_gapTrackBounceViaScroll', 25]);
_gap.push(['_gapTrackReads', 60, 10]);
_gap.push(['_gapTrackLinkClicks']);
if (document.location.hostname != 'localhost') (function() {
    var gap = document.createElement('script');
    gap.async = true;
    gap.type = 'text/javascript';
    gap.src = '/js/gap.min.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gap, s);
})();
              </script><!-- End of counters --></footer><script async="" src="./Implementation of A__files/counter_xhtml.js.下载"></script>
</body><loom-container id="lo-engage-ext-container"><loom-shadow classname="resolved"></loom-shadow></loom-container></html>
